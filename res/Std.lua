-- Generated by Haxe 4.3.7
local _hx_do_first_1, _hx_do_first_2, _hx_do_first_3, _hx_do_first_4, _hx_do_first_5;

local _hx_bit_raw = bit32
local _hx_bit = _hx_bit_raw

local function _hx_bit_clamp(v)
    if v <= 2147483647 and v >= -2147483648 then
        if v > 0 then return math.floor(v)
        else return math.ceil(v)
        end
    end
    if v > 2251798999999999 then v = v*2 end;
    if (v ~= v or math.abs(v) == math.huge) then return nil end
    return _hx_bit_raw.band(v, 2147483647 ) - math.abs(_hx_bit_raw.band(v, 2147483648))
end

local function _hx_funcToField(f)
  if type(f) == 'function' then
    return function(self,...)
      return f(...)
    end
  else
    return f
  end
end

local function _hx_handle_error(obj)
  local message = tostring(obj)
  if debug and debug.traceback then
    -- level 2 to skip _hx_handle_error
    message = debug.traceback(message, 2)
  end
  return setmetatable({}, { __tostring = function() return message end })
end

local function _hx_staticToInstance(tab)
  return setmetatable({}, {
    __index = function(t,k)
      if type(rawget(tab,k)) == 'function' then
    return function(self,...)
      return rawget(tab,k)(...)
    end
      else
    return rawget(tab,k)
      end
    end
  })
end

local _hx_hidden = {__id__=true, hx__closures=true, super=true, prototype=true, __ifields__=true, __class__=true, __properties__=true, __fields__=true, __name__=true}

local _hx_array_mt = {
    __newindex = function(t,k,v)
        local len = t.length
        t.length =  k >= len and (k + 1) or len
        rawset(t,k,v)
    end
}

local function _hx_is_array(o)
    return type(o) == "table"
        and o.__enum__ == nil
        and getmetatable(o) == _hx_array_mt
end


local _hx_tostring;

local function _hx_tab_array(tab, length)
    tab.length = length
    return setmetatable(tab, _hx_array_mt)
end

local function _hx_print_class(obj, depth)
    local first = true
    local result = ''
    for k,v in pairs(obj) do
        if _hx_hidden[k] == nil then
            if first then
                first = false
            else
                result = result .. ', '
            end
            if _hx_hidden[k] == nil then
                result = result .. k .. ':' .. _hx_tostring(v, depth+1)
            end
        end
    end
    return '{ ' .. result .. ' }'
end

local function _hx_print_enum(o, depth)
    if o.length == 2 then
        return o[0]
    else
        local str = o[0] .. "("
        for i = 2, (o.length-1) do
            if i ~= 2 then
                str = str .. "," .. _hx_tostring(o[i], depth+1)
            else
                str = str .. _hx_tostring(o[i], depth+1)
            end
        end
        return str .. ")"
    end
end

_hx_tostring = function(obj, depth)
    if depth == nil then
        depth = 0
    elseif depth > 5 then
        return "<...>"
    end

    local tstr = type(obj)
    if tstr == "string" then return obj
    elseif tstr == "nil" then return "null"
    elseif tstr == "number" then
        if obj == math.huge then return "Infinity"
        elseif obj == -math.huge then return "-Infinity"
        elseif obj == 0 then return "0"
        elseif obj ~= obj then return "NaN"
        else return tostring(obj)
        end
    elseif tstr == "boolean" then return tostring(obj)
    elseif tstr == "userdata" then
        local mt = getmetatable(obj)
        if mt ~= nil and mt.__tostring ~= nil then
            return tostring(obj)
        else
            return "<userdata>"
        end
    elseif tstr == "function" then return "<function>"
    elseif tstr == "thread" then return "<thread>"
    elseif tstr == "table" then
        if obj.__enum__ ~= nil then
            return _hx_print_enum(obj, depth)
        elseif obj.toString ~= nil and not _hx_is_array(obj) then return obj:toString()
        elseif _hx_is_array(obj) then
            if obj.length > 5 then
                return "[...]"
            else
                local str = ""
                for i=0, (obj.length-1) do
                    if i == 0 then
                        str = str .. _hx_tostring(obj[i], depth+1)
                    else
                        str = str .. "," .. _hx_tostring(obj[i], depth+1)
                    end
                end
                return "[" .. str .. "]"
            end
        elseif obj.__class__ ~= nil then
            return _hx_print_class(obj, depth)
        else
            local buffer = {}
            local ref = obj
            if obj.__fields__ ~= nil then
                ref = obj.__fields__
            end
            for k,v in pairs(ref) do
                if _hx_hidden[k] == nil then
                    table.insert(buffer, _hx_tostring(k, depth+1) .. ' : ' .. _hx_tostring(obj[k], depth+1))
                end
            end

            return "{ " .. table.concat(buffer, ", ") .. " }"
        end
    else
        error("Unknown Lua type", 0)
        return ""
    end
end

--[[ -- Haxe does not appear to need to use this _hx_table thing, we can just use the regular lua table class itself
local _hx_table = {}
_hx_table.pack = table.pack
_hx_table.unpack = table.unpack or unpack
_hx_table.maxn = table.maxn
--]]

local function _hx_dyn_add(a,b)
  if (type(a) == 'string' or type(b) == 'string') then
    return _hx_tostring(a, 0).._hx_tostring(b, 0)
  else
    return a + b;
  end;
end;

local String;
local function _hx_wrap_if_string_field(o, fld)
  if type(o) == 'string' then
    if fld == 'length' then
      return string.len(o)
    else
      return String.prototype[fld]
    end
  else
    return o[fld]
  end
end

local function _hx_obj_newindex(t,k,v)
    t.__fields__[k] = true
    rawset(t,k,v)
end

local _hx_obj_mt = {__newindex=_hx_obj_newindex, __tostring=_hx_tostring}

local function _hx_a(...)
  local __fields__ = {};
  local ret = {__fields__ = __fields__};
  local max = select('#',...);
  local tab = {...};
  local cur = 1;
  while cur < max do
    local v = tab[cur];
    __fields__[v] = true;
    ret[v] = tab[cur+1];
    cur = cur + 2
  end
  return setmetatable(ret, _hx_obj_mt)
end

local function _hx_e()
  return setmetatable({__fields__ = {}}, _hx_obj_mt)
end

local function _hx_o(obj)
  return setmetatable(obj, _hx_obj_mt)
end

local function _hx_new(prototype)
  return setmetatable({__fields__ = {}}, {__newindex=_hx_obj_newindex, __index=prototype, __tostring=_hx_tostring})
end

local function _hx_field_arr(obj)
    local res = {}
    local idx = 0
    if obj.__fields__ ~= nil then
        obj = obj.__fields__
    end
    for k,v in pairs(obj) do
        if _hx_hidden[k] == nil then
            res[idx] = k
            idx = idx + 1
        end
    end
    return _hx_tab_array(res, idx)
end

local function _hx_apply_self(self, f, ...)
  return self[f](self,...)
end

local function _hx_box_mr(x,nt)
    local res = _hx_o({__fields__={}})
    for i,v in ipairs(nt) do
      res[v] = x[i]
    end
    return res
end

local function _hx_bind(o,m)
  if m == nil then return nil end;
  local f;
  if o._hx__closures == nil then
    rawset(o, '_hx__closures', {});
  else
    f = o._hx__closures[m];
  end
  if (f == nil) then
    f = function(...) return m(o, ...) end;
    o._hx__closures[m] = f;
  end
  return f;
end

math.randomseed(os.time());

local _hxClasses = {}
local Int = _hx_e();
local Dynamic = _hx_e();
local Float = _hx_e();
local Bool = _hx_e();
local Class = _hx_e();
local Enum = _hx_e();



local Array = _hx_e()
local Date = _hx_e()
local EReg = _hx_e()
local ___EnumValue_EnumValue_Impl_ = _hx_e()
local IntIterator = _hx_e()
local Lambda = _hx_e()
local Math = _hx_e()
local Reflect = _hx_e()
String = _hx_e()
local Std = _hx_e()
local StringBuf = _hx_e()
local __haxe_SysTools = _hx_e()
local StringTools = _hx_e()
local ValueType = _hx_e()
local Type = _hx_e()
local __haxe_StackItem = _hx_e()
local __haxe__CallStack_CallStack_Impl_ = _hx_e()
local __haxe_IMap = _hx_e()
local __haxe_Exception = _hx_e()
local __haxe_Json = _hx_e()
local __haxe_Log = _hx_e()
local __haxe_NativeStackTrace = _hx_e()
local __haxe__Rest_Rest_Impl_ = _hx_e()
local __haxe__Template_TemplateExpr = _hx_e()
local __haxe_iterators_ArrayIterator = _hx_e()
local __haxe_Template = _hx_e()
local __haxe_ValueException = _hx_e()
local __haxe_ds_BalancedTree = _hx_e()
local __haxe_ds_TreeNode = _hx_e()
local __haxe_ds_EnumValueMap = _hx_e()
local __haxe_ds_IntMap = _hx_e()
local __haxe_ds_List = _hx_e()
local __haxe_ds__List_ListNode = _hx_e()
local __haxe_ds__List_ListIterator = _hx_e()
local __haxe_ds__List_ListKeyValueIterator = _hx_e()
local __haxe_ds__Map_Map_Impl_ = _hx_e()
local __haxe_ds_ObjectMap = _hx_e()
local __haxe_ds__ReadOnlyArray_ReadOnlyArray_Impl_ = _hx_e()
local __haxe_ds_StringMap = _hx_e()
local __haxe_format_JsonParser = _hx_e()
local __haxe_format_JsonPrinter = _hx_e()
local __haxe_iterators_ArrayKeyValueIterator = _hx_e()
local __haxe_iterators_MapKeyValueIterator = _hx_e()
local __haxe_iterators_RestIterator = _hx_e()
local __haxe_iterators_RestKeyValueIterator = _hx_e()
local __haxe_iterators_StringIterator = _hx_e()
local __haxe_iterators_StringIteratorUnicode = _hx_e()
local __haxe_iterators_StringKeyValueIterator = _hx_e()
local __lua_Boot = _hx_e()
local __lua_Lib = _hx_e()
local __lua__Lua_Lua_Fields_ = _hx_e()
local __lua_PairTools = _hx_e()
local __lua_Thread = _hx_e()
local __lua_UserData = _hx_e()

local _hx_bind, _hx_bit, _hx_staticToInstance, _hx_funcToField, _hx_maxn, _hx_print, _hx_apply_self, _hx_box_mr, _hx_bit_clamp, _hx_table, _hx_bit_raw
local _hx_pcall_default = {};
local _hx_pcall_break = {};

Array.new = function() 
  local self = _hx_new(Array.prototype)
  Array.super(self)
  return self
end
Array.super = function(self) 
  _hx_tab_array(self, 0);
end
_hxClasses["Array"] = Array
Array.__name__ = "Array"
Array.prototype = _hx_e();
Array.prototype.length= nil;
Array.prototype.concat = function(self,a) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
  end;
  local ret = _g;
  local _g = 0;
  while (_g < a.length) do _hx_do_first_1 = false;
    
    local i = a[_g];
    _g = _g + 1;
    ret:push(i);
  end;
  do return ret end
end
Array.prototype.join = function(self,sep) 
  local tbl = {};
  local _g_current = 0;
  local _g_array = self;
  while (_g_current < _g_array.length) do _hx_do_first_1 = false;
    
    _g_current = _g_current + 1;
    local i = _g_array[_g_current - 1];
    table.insert(tbl, Std.string(i));
  end;
  do return table.concat(tbl, sep) end
end
Array.prototype.pop = function(self) 
  if (self.length == 0) then 
    do return nil end;
  end;
  local ret = self[self.length - 1];
  self[self.length - 1] = nil;
  self.length = self.length - 1;
  do return ret end
end
Array.prototype.push = function(self,x) 
  self[self.length] = x;
  do return self.length end
end
Array.prototype.reverse = function(self) 
  local tmp;
  local i = 0;
  while (i < Std.int(self.length / 2)) do _hx_do_first_1 = false;
    
    tmp = self[i];
    self[i] = self[(self.length - i) - 1];
    self[(self.length - i) - 1] = tmp;
    i = i + 1;
  end;
end
Array.prototype.shift = function(self) 
  if (self.length == 0) then 
    do return nil end;
  end;
  local ret = self[0];
  if (self.length == 1) then 
    self[0] = nil;
  else
    if (self.length > 1) then 
      self[0] = self[1];
      table.remove(self, 1);
    end;
  end;
  local tmp = self;
  tmp.length = tmp.length - 1;
  do return ret end
end
Array.prototype.slice = function(self,pos,_end) 
  if ((_end == nil) or (_end > self.length)) then 
    _end = self.length;
  else
    if (_end < 0) then 
      _end = math.fmod((self.length - (math.fmod(-_end, self.length))), self.length);
    end;
  end;
  if (pos < 0) then 
    pos = math.fmod((self.length - (math.fmod(-pos, self.length))), self.length);
  end;
  if ((pos > _end) or (pos > self.length)) then 
    do return _hx_tab_array({}, 0) end;
  end;
  local ret = _hx_tab_array({}, 0);
  local _g = pos;
  local _g1 = _end;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    ret:push(self[i]);
  end;
  do return ret end
end
Array.prototype.sort = function(self,f) 
  local i = 0;
  local l = self.length;
  while (i < l) do _hx_do_first_1 = false;
    
    local swap = false;
    local j = 0;
    local max = (l - i) - 1;
    while (j < max) do _hx_do_first_2 = false;
      
      if (f(self[j], self[j + 1]) > 0) then 
        local tmp = self[j + 1];
        self[j + 1] = self[j];
        self[j] = tmp;
        swap = true;
      end;
      j = j + 1;
    end;
    if (not swap) then 
      break;
    end;
    i = i + 1;
  end;
end
Array.prototype.splice = function(self,pos,len) 
  if ((len < 0) or (pos > self.length)) then 
    do return _hx_tab_array({}, 0) end;
  else
    if (pos < 0) then 
      pos = self.length - (math.fmod(-pos, self.length));
    end;
  end;
  len = Math.min(len, self.length - pos);
  local ret = _hx_tab_array({}, 0);
  local _g = pos;
  local _g1 = pos + len;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    ret:push(self[i]);
    self[i] = self[i + len];
  end;
  local _g = pos + len;
  local _g1 = self.length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    self[i] = self[i + len];
  end;
  local tmp = self;
  tmp.length = tmp.length - len;
  do return ret end
end
Array.prototype.toString = function(self) 
  local tbl = {};
  table.insert(tbl, "[");
  table.insert(tbl, self:join(","));
  table.insert(tbl, "]");
  do return table.concat(tbl, "") end
end
Array.prototype.unshift = function(self,x) 
  local len = self.length;
  local _g = 0;
  local _g1 = len;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    self[len - i] = self[(len - i) - 1];
  end;
  self[0] = x;
end
Array.prototype.insert = function(self,pos,x) 
  if (pos > self.length) then 
    pos = self.length;
  end;
  if (pos < 0) then 
    pos = self.length + pos;
    if (pos < 0) then 
      pos = 0;
    end;
  end;
  local cur_len = self.length;
  while (cur_len > pos) do _hx_do_first_1 = false;
    
    self[cur_len] = self[cur_len - 1];
    cur_len = cur_len - 1;
  end;
  self[pos] = x;
end
Array.prototype.remove = function(self,x) 
  local _g = 0;
  local _g1 = self.length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    if (self[i] == x) then 
      local _g = i;
      local _g1 = self.length - 1;
      while (_g < _g1) do _hx_do_first_2 = false;
        
        _g = _g + 1;
        local j = _g - 1;
        self[j] = self[j + 1];
      end;
      self[self.length - 1] = nil;
      self.length = self.length - 1;
      do return true end;
    end;
  end;
  do return false end
end
Array.prototype.contains = function(self,x) 
  local _g = 0;
  local _g1 = self.length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    if (self[i] == x) then 
      do return true end;
    end;
  end;
  do return false end
end
Array.prototype.indexOf = function(self,x,fromIndex) 
  local _end = self.length;
  if (fromIndex == nil) then 
    fromIndex = 0;
  else
    if (fromIndex < 0) then 
      fromIndex = self.length + fromIndex;
      if (fromIndex < 0) then 
        fromIndex = 0;
      end;
    end;
  end;
  local _g = fromIndex;
  local _g1 = _end;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    if (x == self[i]) then 
      do return i end;
    end;
  end;
  do return -1 end
end
Array.prototype.lastIndexOf = function(self,x,fromIndex) 
  if ((fromIndex == nil) or (fromIndex >= self.length)) then 
    fromIndex = self.length - 1;
  else
    if (fromIndex < 0) then 
      fromIndex = self.length + fromIndex;
      if (fromIndex < 0) then 
        do return -1 end;
      end;
    end;
  end;
  local i = fromIndex;
  while (i >= 0) do _hx_do_first_1 = false;
    
    if (self[i] == x) then 
      do return i end;
    else
      i = i - 1;
    end;
  end;
  do return -1 end
end
Array.prototype.copy = function(self) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
  end;
  do return _g end
end
Array.prototype.map = function(self,f) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(f(i));
  end;
  do return _g end
end
Array.prototype.filter = function(self,f) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    if (f(i)) then 
      _g:push(i);
    end;
  end;
  do return _g end
end
Array.prototype.iterator = function(self) 
  do return __haxe_iterators_ArrayIterator.new(self) end
end
Array.prototype.keyValueIterator = function(self) 
  do return __haxe_iterators_ArrayKeyValueIterator.new(self) end
end
Array.prototype.resize = function(self,len) 
  if (self.length < len) then 
    self.length = len;
  else
    if (self.length > len) then 
      local _g = len;
      local _g1 = self.length;
      while (_g < _g1) do _hx_do_first_1 = false;
        
        _g = _g + 1;
        local i = _g - 1;
        self[i] = nil;
      end;
      self.length = len;
    end;
  end;
end

Array.prototype.__class__ =  Array

Date.new = function(year,month,day,hour,min,sec) 
  local self = _hx_new(Date.prototype)
  Date.super(self,year,month,day,hour,min,sec)
  return self
end
Date.super = function(self,year,month,day,hour,min,sec) 
  self.t = os.time(_hx_o({__fields__={year=true,month=true,day=true,hour=true,min=true,sec=true},year=year,month=month + 1,day=day,hour=hour,min=min,sec=sec}));
  self.d = os.date("*t", self.t);
  self.dUTC = os.date("!*t", self.t);
end
_hxClasses["Date"] = Date
Date.__name__ = "Date"
Date.now = function() 
  local t = os.time() * 1000;
  local d = _hx_e();
  setmetatable(d, _hx_o({__fields__={__index=true},__index=Date.prototype}));
  d.t = t / 1000;
  d.d = os.date("*t", Std.int(d.t));
  d.dUTC = os.date("!*t", Std.int(d.t));
  do return d end;
end
Date.fromTime = function(t) 
  local d = _hx_e();
  setmetatable(d, _hx_o({__fields__={__index=true},__index=Date.prototype}));
  d.t = t / 1000;
  d.d = os.date("*t", Std.int(d.t));
  d.dUTC = os.date("!*t", Std.int(d.t));
  do return d end;
end
Date.fromString = function(s) 
  do return __lua_Boot.strDate(s) end;
end
Date.prototype = _hx_e();
Date.prototype.d= nil;
Date.prototype.dUTC= nil;
Date.prototype.t= nil;
Date.prototype.getTime = function(self) 
  do return self.t * 1000 end
end
Date.prototype.getHours = function(self) 
  do return self.d.hour end
end
Date.prototype.getMinutes = function(self) 
  do return self.d.min end
end
Date.prototype.getSeconds = function(self) 
  do return self.d.sec end
end
Date.prototype.getFullYear = function(self) 
  do return self.d.year end
end
Date.prototype.getMonth = function(self) 
  do return self.d.month - 1 end
end
Date.prototype.getDate = function(self) 
  do return self.d.day end
end
Date.prototype.getDay = function(self) 
  do return self.d.wday - 1 end
end
Date.prototype.getUTCHours = function(self) 
  do return self.dUTC.hour end
end
Date.prototype.getUTCMinutes = function(self) 
  do return self.dUTC.min end
end
Date.prototype.getUTCSeconds = function(self) 
  do return self.dUTC.sec end
end
Date.prototype.getUTCFullYear = function(self) 
  do return self.dUTC.year end
end
Date.prototype.getUTCMonth = function(self) 
  do return self.dUTC.month - 1 end
end
Date.prototype.getUTCDate = function(self) 
  do return self.dUTC.day end
end
Date.prototype.getUTCDay = function(self) 
  do return self.dUTC.wday - 1 end
end
Date.prototype.getTimezoneOffset = function(self) 
  local tUTC = os.time(self.dUTC);
  do return Std.int((tUTC - self.t) / 60) end
end
Date.prototype.toString = function(self) 
  do return __lua_Boot.dateStr(self) end
end

Date.prototype.__class__ =  Date

EReg.new = function(r,opt) 
  local self = _hx_new(EReg.prototype)
  EReg.super(self,r,opt)
  return self
end
EReg.super = function(self,r,opt) 
  self.global = false;
  self.r = r;
end
_hxClasses["EReg"] = EReg
EReg.__name__ = "EReg"
EReg.escape = function(s) 
  do return EReg.escapeRegExpRe:map(s, function(r) 
    do return Std.string("\\") .. Std.string(r:matched(0)) end;
  end) end;
end
EReg.prototype = _hx_e();
EReg.prototype.r= nil;
EReg.prototype.global= nil;
EReg.prototype.s= nil;
EReg.prototype.m= nil;
EReg.prototype.match = function(self,s) 
  if (s == nil) then 
    do return false end;
  else
    self.m = table.pack();
    self.s = s;
    do return self.m[1] ~= nil end;
  end;
end
EReg.prototype.matchFromByte = function(self,s,offset) 
  if (s == nil) then 
    do return false end;
  end;
  self.m = table.pack();
  self.s = s;
  do return self.m[1] ~= nil end
end
EReg.prototype.matched = function(self,n) 
  if ((self.m[1] == nil) or (n < 0)) then 
    error(__haxe_Exception.thrown("EReg::matched"),0);
  else
    if (n == 0) then 
      local k = string.sub(self.s, self.m[1], self.m[2]);
      do return k end;
    else
      if (__lua_Boot.__instanceof(self.m[3], table)) then 
        local mn = 2 * (n - 1);
        if (__lua_Boot.__instanceof(self.m[3][mn + 1], Bool)) then 
          do return nil end;
        end;
        do return string.sub(self.s, self.m[3][mn + 1], self.m[3][mn + 2]) end;
      else
        error(__haxe_Exception.thrown("EReg:matched"),0);
      end;
    end;
  end;
end
EReg.prototype.matchedLeft = function(self) 
  if (self.m[1] == nil) then 
    error(__haxe_Exception.thrown("No string matched"),0);
  end;
  do return string.sub(self.s, 1, self.m[1] - 1) end
end
EReg.prototype.matchedRight = function(self) 
  if (self.m[1] == nil) then 
    error(__haxe_Exception.thrown("No string matched"),0);
  end;
  do return string.sub(self.s, self.m[2] + 1) end
end
EReg.prototype.matchedPos = function(self) 
  local left = self:matchedLeft();
  local matched = self:matched(0);
  if (self.m[1] == nil) then 
    error(__haxe_Exception.thrown("No string matched"),0);
  end;
  do return _hx_o({__fields__={pos=true,len=true},pos=#(left),len=#(matched)}) end
end
EReg.prototype.matchSub = function(self,s,pos,len) 
  if (len == nil) then 
    len = -1;
  end;
  local ss = String.prototype.substr(s, 0, (function() 
    local _hx_1
    if (len < 0) then 
    _hx_1 = #(s); else 
    _hx_1 = pos + len; end
    return _hx_1
  end )());
  local b = self.m[1] ~= nil;
  if (b) then 
    self.s = s;
  end;
  do return b end
end
EReg.prototype.split = function(self,s) 
  do return String.prototype.split(self.r, s) end
end
EReg.prototype.replace = function(self,s,by) 
  local chunks = String.prototype.split(by, "$$");
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  while (_g1 < chunks.length) do _hx_do_first_1 = false;
    
    local chunk = chunks[_g1];
    _g1 = _g1 + 1;
    _g:push(string.gsub(self.r, "\\$(\\d)", "%%%1", 1));
  end;
  chunks = _g;
  by = chunks:join("$");
  do return string.gsub(self.r, s, by, (function() 
    local _hx_1
    if (self.global) then 
    _hx_1 = nil; else 
    _hx_1 = 1; end
    return _hx_1
  end )()) end
end
EReg.prototype.map = function(self,s,f) 
  local bytesOffset = 1;
  local buf_b = {};
  local buf_length = 0;
  local _hx_do_first_1 = true;
  while (self.global) or _hx_do_first_1 do 
    _hx_do_first_1 = false;
    
    if (bytesOffset > string.len(s)) then 
      break;
    else
      local tmp;
      if (s == nil) then 
        tmp = false;
      else
        self.m = table.pack();
        self.s = s;
        tmp = self.m[1] ~= nil;
      end;
      if (not tmp) then 
        local str = Std.string(string.sub(s, bytesOffset));
        table.insert(buf_b, str);
        buf_length = buf_length + #(str);
        break;
      end;
    end;
    local pos = self.m[1];
    local length = self.m[2] - self.m[1];
    local str = Std.string(string.sub(s, bytesOffset, pos - 1));
    table.insert(buf_b, str);
    buf_length = buf_length + #(str);
    local str = Std.string(f(self));
    table.insert(buf_b, str);
    buf_length = buf_length + #(str);
    if (length < 0) then 
      local charBytes = string.len(string.sub(string.sub(s, pos), 1, 1));
      local str = Std.string(string.sub(s, pos, (pos + charBytes) - 1));
      table.insert(buf_b, str);
      buf_length = buf_length + #(str);
      bytesOffset = pos + charBytes;
    else
      bytesOffset = self.m[2] + 1;
    end;
  end;
  if ((not self.global and (bytesOffset > 1)) and ((bytesOffset - 1) < string.len(s))) then 
    local str = Std.string(string.sub(s, bytesOffset));
    table.insert(buf_b, str);
    buf_length = buf_length + #(str);
  end;
  do return table.concat(buf_b) end
end
EReg.prototype.map_old = function(self,s,f) 
  local offset = 0;
  local buf_b = {};
  local buf_length = 0;
  local _hx_do_first_1 = true;
  while (self.global) or _hx_do_first_1 do 
    _hx_do_first_1 = false;
    
    if (offset >= #(s)) then 
      break;
    else
      if (not self:matchSub(s, offset)) then 
        local str = Std.string(String.prototype.substr(s, offset));
        table.insert(buf_b, str);
        buf_length = buf_length + #(str);
        break;
      end;
    end;
    local p = self:matchedPos();
    local str = Std.string(String.prototype.substr(s, offset, p.pos - offset));
    table.insert(buf_b, str);
    buf_length = buf_length + #(str);
    local str = Std.string(f(self));
    table.insert(buf_b, str);
    buf_length = buf_length + #(str);
    if (p.len == 0) then 
      local str = Std.string(String.prototype.substr(s, p.pos, 1));
      table.insert(buf_b, str);
      buf_length = buf_length + #(str);
      offset = p.pos + 1;
    else
      offset = p.pos + p.len;
    end;
  end;
  if ((not self.global and (offset > 0)) and (offset < #(s))) then 
    local str = Std.string(String.prototype.substr(s, offset));
    table.insert(buf_b, str);
    buf_length = buf_length + #(str);
  end;
  do return table.concat(buf_b) end
end

EReg.prototype.__class__ =  EReg

___EnumValue_EnumValue_Impl_.new = {}
_hxClasses["_EnumValue.EnumValue_Impl_"] = ___EnumValue_EnumValue_Impl_
___EnumValue_EnumValue_Impl_.__name__ = "_EnumValue.EnumValue_Impl_"
___EnumValue_EnumValue_Impl_.match = function(this1,pattern) 
  do return false end;
end

IntIterator.new = function(min,max) 
  local self = _hx_new(IntIterator.prototype)
  IntIterator.super(self,min,max)
  return self
end
IntIterator.super = function(self,min,max) 
  self.min = min;
  self.max = max;
end
_hxClasses["IntIterator"] = IntIterator
IntIterator.__name__ = "IntIterator"
IntIterator.prototype = _hx_e();
IntIterator.prototype.min= nil;
IntIterator.prototype.max= nil;
IntIterator.prototype.hasNext = function(self) 
  do return self.min < self.max end
end
IntIterator.prototype.next = function(self) 
  do return (function() 
  local _hx_obj = self;
  local _hx_fld = 'min';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)() end
end

IntIterator.prototype.__class__ =  IntIterator

Lambda.new = {}
_hxClasses["Lambda"] = Lambda
Lambda.__name__ = "Lambda"
Lambda.array = function(it) 
  local a = Array.new();
  local i = it:iterator();
  while (i:hasNext()) do _hx_do_first_1 = false;
    
    local i = i:next();
    a:push(i);
  end;
  do return a end;
end
Lambda.list = function(it) 
  local l = __haxe_ds_List.new();
  local i = it:iterator();
  while (i:hasNext()) do _hx_do_first_1 = false;
    
    local i = i:next();
    l:add(i);
  end;
  do return l end;
end
Lambda.map = function(it,f) 
  local _g = _hx_tab_array({}, 0);
  local x = it:iterator();
  while (x:hasNext()) do _hx_do_first_1 = false;
    
    local x = x:next();
    _g:push(f(x));
  end;
  do return _g end;
end
Lambda.mapi = function(it,f) 
  local i = 0;
  local _g = _hx_tab_array({}, 0);
  local x = it:iterator();
  while (x:hasNext()) do _hx_do_first_1 = false;
    
    local x = x:next();
    i = i + 1;
    _g:push(f(i - 1, x));
  end;
  do return _g end;
end
Lambda.flatten = function(it) 
  local _g = _hx_tab_array({}, 0);
  local e = it:iterator();
  while (e:hasNext()) do _hx_do_first_1 = false;
    
    local e = e:next();
    local x = e:iterator();
    while (x:hasNext()) do _hx_do_first_2 = false;
      
      local x = x:next();
      _g:push(x);
    end;
  end;
  do return _g end;
end
Lambda.flatMap = function(it,f) 
  local _g = _hx_tab_array({}, 0);
  local x = it:iterator();
  while (x:hasNext()) do _hx_do_first_1 = false;
    
    local x = x:next();
    _g:push(f(x));
  end;
  local _g1 = _hx_tab_array({}, 0);
  local e = _g:iterator();
  while (e:hasNext()) do _hx_do_first_1 = false;
    
    local e = e:next();
    local x = e:iterator();
    while (x:hasNext()) do _hx_do_first_2 = false;
      
      local x = x:next();
      _g1:push(x);
    end;
  end;
  do return _g1 end;
end
Lambda.has = function(it,elt) 
  local x = it:iterator();
  while (x:hasNext()) do _hx_do_first_1 = false;
    
    local x = x:next();
    if (x == elt) then 
      do return true end;
    end;
  end;
  do return false end;
end
Lambda.exists = function(it,f) 
  local x = it:iterator();
  while (x:hasNext()) do _hx_do_first_1 = false;
    
    local x = x:next();
    if (f(x)) then 
      do return true end;
    end;
  end;
  do return false end;
end
Lambda.foreach = function(it,f) 
  local x = it:iterator();
  while (x:hasNext()) do _hx_do_first_1 = false;
    
    local x = x:next();
    if (not f(x)) then 
      do return false end;
    end;
  end;
  do return true end;
end
Lambda.iter = function(it,f) 
  local x = it:iterator();
  while (x:hasNext()) do _hx_do_first_1 = false;
    
    local x = x:next();
    f(x);
  end;
end
Lambda.filter = function(it,f) 
  local _g = _hx_tab_array({}, 0);
  local x = it:iterator();
  while (x:hasNext()) do _hx_do_first_1 = false;
    
    local x = x:next();
    if (f(x)) then 
      _g:push(x);
    end;
  end;
  do return _g end;
end
Lambda.fold = function(it,f,first) 
  local x = it:iterator();
  while (x:hasNext()) do _hx_do_first_1 = false;
    
    local x = x:next();
    first = f(x, first);
  end;
  do return first end;
end
Lambda.foldi = function(it,f,first) 
  local i = 0;
  local x = it:iterator();
  while (x:hasNext()) do _hx_do_first_1 = false;
    
    local x = x:next();
    first = f(x, first, i);
    i = i + 1;
  end;
  do return first end;
end
Lambda.count = function(it,pred) 
  local n = 0;
  if (pred == nil) then 
    local _ = it:iterator();
    while (_:hasNext()) do _hx_do_first_1 = false;
      
      local _ = _:next();
      n = n + 1;
    end;
  else
    local x = it:iterator();
    while (x:hasNext()) do _hx_do_first_1 = false;
      
      local x = x:next();
      if (pred(x)) then 
        n = n + 1;
      end;
    end;
  end;
  do return n end;
end
Lambda.empty = function(it) 
  do return not it:iterator():hasNext() end;
end
Lambda.indexOf = function(it,v) 
  local i = 0;
  local v2 = it:iterator();
  while (v2:hasNext()) do _hx_do_first_1 = false;
    
    local v2 = v2:next();
    if (v == v2) then 
      do return i end;
    end;
    i = i + 1;
  end;
  do return -1 end;
end
Lambda.find = function(it,f) 
  local v = it:iterator();
  while (v:hasNext()) do _hx_do_first_1 = false;
    
    local v = v:next();
    if (f(v)) then 
      do return v end;
    end;
  end;
  do return nil end;
end
Lambda.findIndex = function(it,f) 
  local i = 0;
  local v = it:iterator();
  while (v:hasNext()) do _hx_do_first_1 = false;
    
    local v = v:next();
    if (f(v)) then 
      do return i end;
    end;
    i = i + 1;
  end;
  do return -1 end;
end
Lambda.concat = function(a,b) 
  local l = Array.new();
  local x = a:iterator();
  while (x:hasNext()) do _hx_do_first_1 = false;
    
    local x = x:next();
    l:push(x);
  end;
  local x = b:iterator();
  while (x:hasNext()) do _hx_do_first_1 = false;
    
    local x = x:next();
    l:push(x);
  end;
  do return l end;
end

Math.new = {}
_hxClasses["Math"] = Math
Math.__name__ = "Math"
Math.__properties__ = {get_NaN="get_NaN",get_POSITIVE_INFINITY="get_POSITIVE_INFINITY",get_NEGATIVE_INFINITY="get_NEGATIVE_INFINITY",get_PI="get_PI"}
Math.PI = nil
Math.get_PI = function() 
  do return math.pi end;
end
Math.NEGATIVE_INFINITY = nil
Math.get_NEGATIVE_INFINITY = function() 
  do return -math.huge end;
end
Math.POSITIVE_INFINITY = nil
Math.get_POSITIVE_INFINITY = function() 
  do return math.huge end;
end
Math.NaN = nil
Math.get_NaN = function() 
  do return (0/0) end;
end
Math.isNaN = function(f) 
  do return f ~= f end;
end
Math.isFinite = function(f) 
  if (f > -math.huge) then 
    do return f < math.huge end;
  else
    do return false end;
  end;
end
Math.abs = function(v) 
  do return math.abs(v) end;
end
Math.acos = function(v) 
  do return math.acos(v) end;
end
Math.asin = function(v) 
  do return math.asin(v) end;
end
Math.atan = function(v) 
  do return math.atan(v) end;
end
Math.ceil = function(v) 
  do return math.ceil(v) end;
end
Math.cos = function(v) 
  do return math.cos(v) end;
end
Math.exp = function(v) 
  do return math.exp(v) end;
end
Math.sin = function(v) 
  do return math.sin(v) end;
end
Math.sqrt = function(v) 
  do return math.sqrt(v) end;
end
Math.tan = function(v) 
  do return math.tan(v) end;
end
Math.floor = function(v) 
  do return math.floor(v) end;
end
Math.log = function(v) 
  do return math.log(v) end;
end
Math.random = function() 
  do return math.random() end;
end
Math.atan2 = function(y,x) 
  do return math.atan2(y, x) end;
end
Math.max = function(a,b) 
  if (Math.isNaN(a) or Math.isNaN(b)) then 
    do return (0/0) end;
  else
    do return math.max(a, b) end;
  end;
end
Math.min = function(a,b) 
  if (Math.isNaN(a) or Math.isNaN(b)) then 
    do return (0/0) end;
  else
    do return math.min(a, b) end;
  end;
end
Math.pow = function(v,exp) 
  do return math.pow(v, exp) end;
end
Math.round = function(v) 
  do return math.floor(v + 0.5) end;
end
Math.ffloor = function(v) 
  do return math.floor(v) end;
end
Math.fceil = function(v) 
  do return math.ceil(v) end;
end
Math.fround = function(v) 
  do return math.floor(v + 0.5) end;
end

Reflect.new = {}
_hxClasses["Reflect"] = Reflect
Reflect.__name__ = "Reflect"
Reflect.hasField = function(o,field) 
  if ((__lua__Lua_Lua_Fields_.type(o) == "function") and not ((function() 
    local _hx_1
    if (__lua__Lua_Lua_Fields_.type(o) ~= "table") then 
    _hx_1 = false; else 
    _hx_1 = o.__name__; end
    return _hx_1
  end )() or (function() 
    local _hx_2
    if (__lua__Lua_Lua_Fields_.type(o) ~= "table") then 
    _hx_2 = false; else 
    _hx_2 = o.__ename__; end
    return _hx_2
  end )())) then 
    do return false end;
  else
    if ((__lua__Lua_Lua_Fields_.type(o) == "string") and ((String.prototype[field] ~= nil) or (field == "length"))) then 
      do return true end;
    else
      if (o.__fields__ ~= nil) then 
        do return o.__fields__[field] ~= nil end;
      else
        do return o[field] ~= nil end;
      end;
    end;
  end;
end
Reflect.field = function(o,field) 
  if (__lua__Lua_Lua_Fields_.type(o) == "string") then 
    if (field == "length") then 
      do return _hx_wrap_if_string_field(o,'length') end;
    else
      do return String.prototype[field] end;
    end;
  else
    local _hx_status, _hx_result = pcall(function() 
    
        do return o[field] end;
      return _hx_pcall_default
    end)
    if not _hx_status and _hx_result == "_hx_pcall_break" then
    elseif not _hx_status then 
      local _g = _hx_result;
      do return nil end;
    elseif _hx_result ~= _hx_pcall_default then
      return _hx_result
    end;
  end;
end
Reflect.setField = function(o,field,value) 
  o[field] = value;
end
Reflect.getProperty = function(o,field) 
  if (o == nil) then 
    do return nil end;
  else
    if ((o.__properties__ ~= nil) and (Reflect.field(o, Std.string("get_") .. Std.string(field)) ~= nil)) then 
      do return Reflect.callMethod(o,Reflect.field(o, Std.string("get_") .. Std.string(field)),_hx_tab_array({}, 0)) end;
    else
      do return Reflect.field(o, field) end;
    end;
  end;
end
Reflect.setProperty = function(o,field,value) 
  if ((o.__properties__ ~= nil) and o.__properties__[Std.string("set_") .. Std.string(field)]) then 
    local tmp = o.__properties__[Std.string("set_") .. Std.string(field)];
    Reflect.callMethod(o,Reflect.field(o, tmp),_hx_tab_array({[0]=value}, 1));
  else
    o[field] = value;
  end;
end
Reflect.callMethod = function(o,func,args) 
  if ((args == nil) or (args.length == 0)) then 
    do return func(o) end;
  else
    local self_arg = false;
    if ((o ~= nil) and (o.__name__ == nil)) then 
      self_arg = true;
    end;
    if (self_arg) then 
      do return func(o, table.unpack(args, 0, args.length - 1)) end;
    else
      do return func(table.unpack(args, 0, args.length - 1)) end;
    end;
  end;
end
Reflect.fields = function(o) 
  if (__lua__Lua_Lua_Fields_.type(o) == "string") then 
    do return Reflect.fields(String.prototype) end;
  else
    do return _hx_field_arr(o) end;
  end;
end
Reflect.isFunction = function(f) 
  if (__lua__Lua_Lua_Fields_.type(f) == "function") then 
    do return not ((function() 
      local _hx_1
      if (__lua__Lua_Lua_Fields_.type(f) ~= "table") then 
      _hx_1 = false; else 
      _hx_1 = f.__name__; end
      return _hx_1
    end )() or (function() 
      local _hx_2
      if (__lua__Lua_Lua_Fields_.type(f) ~= "table") then 
      _hx_2 = false; else 
      _hx_2 = f.__ename__; end
      return _hx_2
    end )()) end;
  else
    do return false end;
  end;
end
Reflect.compare = function(a,b) 
  if (a == b) then 
    do return 0 end;
  else
    if (a == nil) then 
      do return -1 end;
    else
      if (b == nil) then 
        do return 1 end;
      else
        if (a > b) then 
          do return 1 end;
        else
          do return -1 end;
        end;
      end;
    end;
  end;
end
Reflect.compareMethods = function(f1,f2) 
  do return f1 == f2 end;
end
Reflect.isObject = function(v) 
  if (v == nil) then 
    do return false end;
  end;
  local t = __lua__Lua_Lua_Fields_.type(v);
  if (not ((t == "string") or ((t == "table") and (v.__enum__ == nil)))) then 
    if (t == "function") then 
      do return ((function() 
        local _hx_1
        if (__lua__Lua_Lua_Fields_.type(v) ~= "table") then 
        _hx_1 = false; else 
        _hx_1 = v.__name__; end
        return _hx_1
      end )() or (function() 
        local _hx_2
        if (__lua__Lua_Lua_Fields_.type(v) ~= "table") then 
        _hx_2 = false; else 
        _hx_2 = v.__ename__; end
        return _hx_2
      end )()) ~= nil end;
    else
      do return false end;
    end;
  else
    do return true end;
  end;
end
Reflect.isEnumValue = function(v) 
  if ((v ~= nil) and __lua_Boot.__instanceof(v, table)) then 
    do return v.__enum__ ~= nil end;
  else
    do return false end;
  end;
end
Reflect.deleteField = function(o,field) 
  if (not ((function() 
    local _hx_1
    if ((__lua__Lua_Lua_Fields_.type(o) == "function") and not ((function() 
      local _hx_2
      if (__lua__Lua_Lua_Fields_.type(o) ~= "table") then 
      _hx_2 = false; else 
      _hx_2 = o.__name__; end
      return _hx_2
    end )() or (function() 
      local _hx_3
      if (__lua__Lua_Lua_Fields_.type(o) ~= "table") then 
      _hx_3 = false; else 
      _hx_3 = o.__ename__; end
      return _hx_3
    end )())) then 
    _hx_1 = false; elseif ((__lua__Lua_Lua_Fields_.type(o) == "string") and ((String.prototype[field] ~= nil) or (field == "length"))) then 
    _hx_1 = true; elseif (o.__fields__ ~= nil) then 
    _hx_1 = o.__fields__[field] ~= nil; else 
    _hx_1 = o[field] ~= nil; end
    return _hx_1
  end )())) then 
    do return false end;
  end;
  o[field] = nil;
  o.__fields__[field] = nil;
  do return true end;
end
Reflect.copy = function(o) 
  if (o == nil) then 
    do return nil end;
  end;
  local o2 = _hx_e();
  local _g = 0;
  local _g1 = Reflect.fields(o);
  while (_g < _g1.length) do _hx_do_first_1 = false;
    
    local f = _g1[_g];
    _g = _g + 1;
    o2[f] = Reflect.field(o, f);
  end;
  do return o2 end;
end
Reflect.makeVarArgs = function(f) 
  do return function(...)
			local a = {...}
			local b = {}
			local l = 0
			for k, v in pairs(a) do
				b[k-1] = v
				l = math.max(k,l)
			end
			return f(_hx_tab_array(b, l))
		end end;
end

String.new = function(string) 
  local self = _hx_new(String.prototype)
  String.super(self,string)
  self = string
  return self
end
String.super = function(self,string) 
end
_hxClasses["String"] = String
String.__name__ = "String"
String.__oldindex = nil
String.__index = function(s,k) 
  if (k == "length") then 
    do return string.len(s) end;
  else
    local o = String.prototype;
    local field = k;
    if ((function() 
      local _hx_1
      if ((__lua__Lua_Lua_Fields_.type(o) == "function") and not ((function() 
        local _hx_2
        if (__lua__Lua_Lua_Fields_.type(o) ~= "table") then 
        _hx_2 = false; else 
        _hx_2 = o.__name__; end
        return _hx_2
      end )() or (function() 
        local _hx_3
        if (__lua__Lua_Lua_Fields_.type(o) ~= "table") then 
        _hx_3 = false; else 
        _hx_3 = o.__ename__; end
        return _hx_3
      end )())) then 
      _hx_1 = false; elseif ((__lua__Lua_Lua_Fields_.type(o) == "string") and ((String.prototype[field] ~= nil) or (field == "length"))) then 
      _hx_1 = true; elseif (o.__fields__ ~= nil) then 
      _hx_1 = o.__fields__[field] ~= nil; else 
      _hx_1 = o[field] ~= nil; end
      return _hx_1
    end )()) then 
      do return String.prototype[k] end;
    else
      if (String.__oldindex ~= nil) then 
        if (__lua__Lua_Lua_Fields_.type(String.__oldindex) == "function") then 
          do return String.__oldindex(s, k) end;
        else
          if (__lua__Lua_Lua_Fields_.type(String.__oldindex) == "table") then 
            do return String.__oldindex[k] end;
          end;
        end;
        do return nil end;
      else
        do return nil end;
      end;
    end;
  end;
end
String.indexOfEmpty = function(s,startIndex) 
  local length = string.len(s);
  if (startIndex < 0) then 
    startIndex = length + startIndex;
    if (startIndex < 0) then 
      startIndex = 0;
    end;
  end;
  if (startIndex > length) then 
    do return length end;
  else
    do return startIndex end;
  end;
end
String.fromCharCode = function(code) 
  do return string.char(code) end;
end
String.prototype = _hx_e();
String.prototype.length= nil;
String.prototype.toUpperCase = function(self) 
  do return string.upper(self) end
end
String.prototype.toLowerCase = function(self) 
  do return string.lower(self) end
end
String.prototype.indexOf = function(self,str,startIndex) 
  if (startIndex == nil) then 
    startIndex = 1;
  else
    startIndex = startIndex + 1;
  end;
  if (str == "") then 
    do return String.indexOfEmpty(self, startIndex - 1) end;
  end;
  local r = string.find(self, str, startIndex, true);
  if ((r ~= nil) and (r > 0)) then 
    do return r - 1 end;
  else
    do return -1 end;
  end;
end
String.prototype.lastIndexOf = function(self,str,startIndex) 
  local ret = -1;
  if (startIndex == nil) then 
    startIndex = #(self);
  end;
  while (true) do _hx_do_first_1 = false;
    
    local p = String.prototype.indexOf(self, str, ret + 1);
    if (((p == -1) or (p > startIndex)) or (p == ret)) then 
      break;
    end;
    ret = p;
  end;
  do return ret end
end
String.prototype.split = function(self,delimiter) 
  local idx = 1;
  local ret = _hx_tab_array({}, 0);
  while (idx ~= nil) do _hx_do_first_1 = false;
    
    local newidx = 0;
    if (#(delimiter) > 0) then 
      newidx = string.find(self, delimiter, idx, true);
    else
      if (idx >= #(self)) then 
        newidx = nil;
      else
        newidx = idx + 1;
      end;
    end;
    if (newidx ~= nil) then 
      local match = string.sub(self, idx, newidx - 1);
      ret:push(match);
      idx = newidx + #(delimiter);
    else
      ret:push(string.sub(self, idx, #(self)));
      idx = nil;
    end;
  end;
  do return ret end
end
String.prototype.toString = function(self) 
  do return self end
end
String.prototype.substring = function(self,startIndex,endIndex) 
  if (endIndex == nil) then 
    endIndex = #(self);
  end;
  if (endIndex < 0) then 
    endIndex = 0;
  end;
  if (startIndex < 0) then 
    startIndex = 0;
  end;
  if (endIndex < startIndex) then 
    do return string.sub(self, endIndex + 1, startIndex) end;
  else
    do return string.sub(self, startIndex + 1, endIndex) end;
  end;
end
String.prototype.charAt = function(self,index) 
  do return string.sub(self, index + 1, index + 1) end
end
String.prototype.charCodeAt = function(self,index) 
  do return string.byte(self, index + 1) end
end
String.prototype.substr = function(self,pos,len) 
  if ((len == nil) or (len > (pos + #(self)))) then 
    len = #(self);
  else
    if (len < 0) then 
      len = #(self) + len;
    end;
  end;
  if (pos < 0) then 
    pos = #(self) + pos;
  end;
  if (pos < 0) then 
    pos = 0;
  end;
  do return string.sub(self, pos + 1, pos + len) end
end

String.prototype.__class__ =  String

Std.new = {}
_hxClasses["Std"] = Std
Std.__name__ = "Std"
Std.is = function(v,t) 
  do return __lua_Boot.__instanceof(v, t) end;
end
Std.isOfType = function(v,t) 
  do return __lua_Boot.__instanceof(v, t) end;
end
Std.downcast = function(value,c) 
  if (__lua_Boot.__instanceof(value, c)) then 
    do return value end;
  else
    do return nil end;
  end;
end
Std.instance = function(value,c) 
  if (__lua_Boot.__instanceof(value, c)) then 
    do return value end;
  else
    do return nil end;
  end;
end
Std.string = function(s) 
  do return _hx_tostring(s, 0) end;
end
Std.int = function(x) 
  if (not Math.isFinite(x) or Math.isNaN(x)) then 
    do return 0 end;
  else
    do return _hx_bit_clamp(x) end;
  end;
end
Std.parseInt = function(x) 
  if (x == nil) then 
    do return nil end;
  end;
  local sign, numString = string.match(x, "^%s*([%-+]?)0[xX]([%da-fA-F]*)");
  if (numString ~= nil) then 
    if (sign == "-") then 
      do return -__lua__Lua_Lua_Fields_.tonumber(numString, 16) end;
    else
      do return __lua__Lua_Lua_Fields_.tonumber(numString, 16) end;
    end;
  end;
  local intMatch = string.match(x, "^%s*[%-+]?%d*");
  if (intMatch == nil) then 
    do return nil end;
  end;
  do return __lua__Lua_Lua_Fields_.tonumber(intMatch) end;
end
Std.parseFloat = function(x) 
  if ((x == nil) or (x == "")) then 
    do return (0/0) end;
  end;
  local digitMatch = string.match(x, "^%s*[%.%-+]?[0-9]%d*");
  if (digitMatch == nil) then 
    do return (0/0) end;
  end;
  x = String.prototype.substr(x, #(digitMatch));
  local decimalMatch = string.match(x, "^%.%d*");
  if (decimalMatch == nil) then 
    decimalMatch = "";
  end;
  x = String.prototype.substr(x, #(decimalMatch));
  local eMatch = string.match(x, "^[eE][+%-]?%d+");
  if (eMatch == nil) then 
    eMatch = "";
  end;
  local result = __lua__Lua_Lua_Fields_.tonumber(Std.string(Std.string(digitMatch) .. Std.string(decimalMatch)) .. Std.string(eMatch));
  if (result ~= nil) then 
    do return result end;
  else
    do return (0/0) end;
  end;
end
Std.random = function(x) 
  if (x <= 0) then 
    do return 0 end;
  else
    do return math.floor(math.random() * x) end;
  end;
end

StringBuf.new = function() 
  local self = _hx_new(StringBuf.prototype)
  StringBuf.super(self)
  return self
end
StringBuf.super = function(self) 
  self.b = {};
  self.length = 0;
end
_hxClasses["StringBuf"] = StringBuf
StringBuf.__name__ = "StringBuf"
StringBuf.prototype = _hx_e();
StringBuf.prototype.b= nil;
StringBuf.prototype.length= nil;
StringBuf.prototype.get_length = function(self) 
  do return self.length end
end
StringBuf.prototype.add = function(self,x) 
  local str = Std.string(x);
  table.insert(self.b, str);
  local tmp = self;
  tmp.length = tmp.length + #(str);
end
StringBuf.prototype.addChar = function(self,c) 
  table.insert(self.b, string.char(c));
  local tmp = self;
  tmp.length = tmp.length + 1;
end
StringBuf.prototype.addSub = function(self,s,pos,len) 
  local part = (function() 
    local _hx_1
    if (len == nil) then 
    _hx_1 = String.prototype.substr(s, pos); else 
    _hx_1 = String.prototype.substr(s, pos, len); end
    return _hx_1
  end )();
  table.insert(self.b, part);
  local tmp = self;
  tmp.length = tmp.length + #(part);
end
StringBuf.prototype.toString = function(self) 
  do return table.concat(self.b) end
end

StringBuf.prototype.__class__ =  StringBuf

StringBuf.prototype.__properties__ =  {get_length="get_length"}

__haxe_SysTools.new = {}
_hxClasses["haxe.SysTools"] = __haxe_SysTools
__haxe_SysTools.__name__ = "haxe.SysTools"
__haxe_SysTools.quoteUnixArg = function(argument) 
  if (argument == "") then 
    do return "''" end;
  end;
  if (not EReg.new("[^a-zA-Z0-9_@%+=:,./-]", ""):match(argument)) then 
    do return argument end;
  end;
  do return Std.string(Std.string("'") .. Std.string(StringTools.replace(argument, "'", "'\"'\"'"))) .. Std.string("'") end;
end
__haxe_SysTools.quoteWinArg = function(argument,escapeMetaCharacters) 
  if (not EReg.new("^(/)?[^ \t/\\\\\"]+$", ""):match(argument)) then 
    local result_b = {};
    local result_length = 0;
    local needquote = (((String.prototype.indexOf(argument, " ") ~= -1) or (String.prototype.indexOf(argument, "\t") ~= -1)) or (argument == "")) or (String.prototype.indexOf(argument, "/") > 0);
    if (needquote) then 
      local str = "\"";
      table.insert(result_b, str);
      result_length = result_length + #(str);
    end;
    local bs_buf = StringBuf.new();
    local _g = 0;
    local _g1 = #(argument);
    while (_g < _g1) do _hx_do_first_1 = false;
      
      _g = _g + 1;
      local i = _g - 1;
      local _g = string.byte(argument, i + 1);
      local _g1 = _g;
      if (_g1) == 34 then 
        local bs = table.concat(bs_buf.b);
        local str = Std.string(bs);
        table.insert(result_b, str);
        result_length = result_length + #(str);
        local str = Std.string(bs);
        table.insert(result_b, str);
        result_length = result_length + #(str);
        bs_buf = StringBuf.new();
        local str = "\\\"";
        table.insert(result_b, str);
        result_length = result_length + #(str);
      elseif (_g1) == 92 then 
        local str = "\\";
        table.insert(bs_buf.b, str);
        local bs_buf = bs_buf;
        bs_buf.length = bs_buf.length + #(str);else
      local c = _g;
      if (bs_buf.length > 0) then 
        local str = Std.string(table.concat(bs_buf.b));
        table.insert(result_b, str);
        result_length = result_length + #(str);
        bs_buf = StringBuf.new();
      end;
      table.insert(result_b, string.char(c));
      result_length = result_length + 1; end;
    end;
    local str = Std.string(table.concat(bs_buf.b));
    table.insert(result_b, str);
    result_length = result_length + #(str);
    if (needquote) then 
      local str = Std.string(table.concat(bs_buf.b));
      table.insert(result_b, str);
      result_length = result_length + #(str);
      local str = "\"";
      table.insert(result_b, str);
      result_length = result_length + #(str);
    end;
    argument = table.concat(result_b);
  end;
  if (escapeMetaCharacters) then 
    local result_b = {};
    local result_length = 0;
    local _g = 0;
    local _g1 = #(argument);
    while (_g < _g1) do _hx_do_first_1 = false;
      
      _g = _g + 1;
      local i = _g - 1;
      local c = string.byte(argument, i + 1);
      if (__haxe_SysTools.winMetaCharacters:indexOf(c) >= 0) then 
        table.insert(result_b, string.char(94));
        result_length = result_length + 1;
      end;
      table.insert(result_b, string.char(c));
      result_length = result_length + 1;
    end;
    do return table.concat(result_b) end;
  else
    do return argument end;
  end;
end

StringTools.new = {}
_hxClasses["StringTools"] = StringTools
StringTools.__name__ = "StringTools"
StringTools.urlEncode = function(s) 
  s = string.gsub(s, "\n", "\r\n");
  s = string.gsub(s, "([^%w %-%_%.%~])", function(c) 
    do return string.format("%%%02X", Std.string(string.byte(c)) .. Std.string("")) end;
  end);
  s = string.gsub(s, " ", "+");
  do return s end;
end
StringTools.urlDecode = function(s) 
  s = string.gsub(s, "+", " ");
  s = string.gsub(s, "%%(%x%x)", function(h) 
    do return string.char(__lua__Lua_Lua_Fields_.tonumber(h, 16)) end;
  end);
  s = string.gsub(s, "\r\n", "\n");
  do return s end;
end
StringTools.htmlEscape = function(s,quotes) 
  local buf_b = {};
  local buf_length = 0;
  local _g_offset = 0;
  local _g_s = s;
  while (_g_offset < #(_g_s)) do _hx_do_first_1 = false;
    
    _g_offset = _g_offset + 1;
    local code = string.byte(_g_s, (_g_offset - 1) + 1);
    local code1 = code;
    if (code1) == 34 then 
      if (quotes) then 
        local str = "&quot;";
        table.insert(buf_b, str);
        buf_length = buf_length + #(str);
      else
        table.insert(buf_b, string.char(code));
        buf_length = buf_length + 1;
      end;
    elseif (code1) == 38 then 
      local str = "&amp;";
      table.insert(buf_b, str);
      buf_length = buf_length + #(str);
    elseif (code1) == 39 then 
      if (quotes) then 
        local str = "&#039;";
        table.insert(buf_b, str);
        buf_length = buf_length + #(str);
      else
        table.insert(buf_b, string.char(code));
        buf_length = buf_length + 1;
      end;
    elseif (code1) == 60 then 
      local str = "&lt;";
      table.insert(buf_b, str);
      buf_length = buf_length + #(str);
    elseif (code1) == 62 then 
      local str = "&gt;";
      table.insert(buf_b, str);
      buf_length = buf_length + #(str);else
    table.insert(buf_b, string.char(code));
    buf_length = buf_length + 1; end;
  end;
  do return table.concat(buf_b) end;
end
StringTools.htmlUnescape = function(s) 
  do return String.prototype.split(String.prototype.split(String.prototype.split(String.prototype.split(String.prototype.split(s, "&gt;"):join(">"), "&lt;"):join("<"), "&quot;"):join("\""), "&#039;"):join("'"), "&amp;"):join("&") end;
end
StringTools.contains = function(s,value) 
  do return String.prototype.indexOf(s, value) ~= -1 end;
end
StringTools.startsWith = function(s,start) 
  do return s:sub(1, #start) == start end;
end
StringTools.endsWith = function(s,_end) 
  if (_end ~= "") then 
    do return s:sub(-#_end) == _end end;
  else
    do return true end;
  end;
end
StringTools.isSpace = function(s,pos) 
  if (((#(s) == 0) or (pos < 0)) or (pos >= #(s))) then 
    do return false end;
  end;
  local c = string.byte(s, pos + 1);
  if (not ((c > 8) and (c < 14))) then 
    do return c == 32 end;
  else
    do return true end;
  end;
end
StringTools.ltrim = function(s) 
  local l = #(s);
  local r = 0;
  while ((r < l) and StringTools.isSpace(s, r)) do _hx_do_first_1 = false;
    
    r = r + 1;
  end;
  if (r > 0) then 
    do return String.prototype.substr(s, r, l - r) end;
  else
    do return s end;
  end;
end
StringTools.rtrim = function(s) 
  local l = #(s);
  local r = 0;
  while ((r < l) and StringTools.isSpace(s, (l - r) - 1)) do _hx_do_first_1 = false;
    
    r = r + 1;
  end;
  if (r > 0) then 
    do return String.prototype.substr(s, 0, l - r) end;
  else
    do return s end;
  end;
end
StringTools.trim = function(s) 
  do return StringTools.ltrim(StringTools.rtrim(s)) end;
end
StringTools.lpad = function(s,c,l) 
  if (#(c) <= 0) then 
    do return s end;
  end;
  local buf_b = {};
  local buf_length = 0;
  l = l - #(s);
  while (buf_length < l) do _hx_do_first_1 = false;
    
    local str = Std.string(c);
    table.insert(buf_b, str);
    buf_length = buf_length + #(str);
  end;
  local str = Std.string(s);
  table.insert(buf_b, str);
  buf_length = buf_length + #(str);
  do return table.concat(buf_b) end;
end
StringTools.rpad = function(s,c,l) 
  if (#(c) <= 0) then 
    do return s end;
  end;
  local buf_b = {};
  local buf_length = 0;
  local str = Std.string(s);
  table.insert(buf_b, str);
  buf_length = buf_length + #(str);
  while (buf_length < l) do _hx_do_first_1 = false;
    
    local str = Std.string(c);
    table.insert(buf_b, str);
    buf_length = buf_length + #(str);
  end;
  do return table.concat(buf_b) end;
end
StringTools.replace = function(s,sub,by) 
  do return String.prototype.split(s, sub):join(by) end;
end
StringTools.hex = function(n,digits) 
  local s = "";
  local hexChars = "0123456789ABCDEF";
  local _hx_do_first_1 = true;
  while (n > 0) or _hx_do_first_1 do 
    _hx_do_first_1 = false;
    
    local index = _hx_bit.band(n,15);
    s = Std.string(string.sub(hexChars, index + 1, index + 1)) .. Std.string(s);
    n = _hx_bit.rshift(n,4);
  end;
  if (digits ~= nil) then 
    while (#(s) < digits) do _hx_do_first_1 = false;
      
      s = Std.string("0") .. Std.string(s);
    end;
  end;
  do return s end;
end
StringTools.fastCodeAt = function(s,index) 
  do return string.byte(s, index + 1) end;
end
StringTools.unsafeCodeAt = function(s,index) 
  do return string.byte(s, index + 1) end;
end
StringTools.iterator = function(s) 
  do return __haxe_iterators_StringIterator.new(s) end;
end
StringTools.keyValueIterator = function(s) 
  do return __haxe_iterators_StringKeyValueIterator.new(s) end;
end
StringTools.isEof = function(c) 
  do return c == nil end;
end
StringTools.quoteUnixArg = function(argument) 
  if (argument == "") then 
    do return "''" end;
  else
    if (not EReg.new("[^a-zA-Z0-9_@%+=:,./-]", ""):match(argument)) then 
      do return argument end;
    else
      do return Std.string(Std.string("'") .. Std.string(StringTools.replace(argument, "'", "'\"'\"'"))) .. Std.string("'") end;
    end;
  end;
end
StringTools.quoteWinArg = function(argument,escapeMetaCharacters) 
  local argument = argument;
  if (not EReg.new("^(/)?[^ \t/\\\\\"]+$", ""):match(argument)) then 
    local result_b = {};
    local result_length = 0;
    local needquote = (((String.prototype.indexOf(argument, " ") ~= -1) or (String.prototype.indexOf(argument, "\t") ~= -1)) or (argument == "")) or (String.prototype.indexOf(argument, "/") > 0);
    if (needquote) then 
      local str = "\"";
      table.insert(result_b, str);
      result_length = result_length + #(str);
    end;
    local bs_buf = StringBuf.new();
    local _g = 0;
    local _g1 = #(argument);
    while (_g < _g1) do _hx_do_first_1 = false;
      
      _g = _g + 1;
      local i = _g - 1;
      local _g = string.byte(argument, i + 1);
      local _g1 = _g;
      if (_g1) == 34 then 
        local bs = table.concat(bs_buf.b);
        local str = Std.string(bs);
        table.insert(result_b, str);
        result_length = result_length + #(str);
        local str = Std.string(bs);
        table.insert(result_b, str);
        result_length = result_length + #(str);
        bs_buf = StringBuf.new();
        local str = "\\\"";
        table.insert(result_b, str);
        result_length = result_length + #(str);
      elseif (_g1) == 92 then 
        local str = "\\";
        table.insert(bs_buf.b, str);
        local bs_buf = bs_buf;
        bs_buf.length = bs_buf.length + #(str);else
      local c = _g;
      if (bs_buf.length > 0) then 
        local str = Std.string(table.concat(bs_buf.b));
        table.insert(result_b, str);
        result_length = result_length + #(str);
        bs_buf = StringBuf.new();
      end;
      table.insert(result_b, string.char(c));
      result_length = result_length + 1; end;
    end;
    local str = Std.string(table.concat(bs_buf.b));
    table.insert(result_b, str);
    result_length = result_length + #(str);
    if (needquote) then 
      local str = Std.string(table.concat(bs_buf.b));
      table.insert(result_b, str);
      result_length = result_length + #(str);
      local str = "\"";
      table.insert(result_b, str);
      result_length = result_length + #(str);
    end;
    argument = table.concat(result_b);
  end;
  if (escapeMetaCharacters) then 
    local result_b = {};
    local result_length = 0;
    local _g = 0;
    local _g1 = #(argument);
    while (_g < _g1) do _hx_do_first_1 = false;
      
      _g = _g + 1;
      local i = _g - 1;
      local c = string.byte(argument, i + 1);
      if (__haxe_SysTools.winMetaCharacters:indexOf(c) >= 0) then 
        table.insert(result_b, string.char(94));
        result_length = result_length + 1;
      end;
      table.insert(result_b, string.char(c));
      result_length = result_length + 1;
    end;
    do return table.concat(result_b) end;
  else
    do return argument end;
  end;
end
_hxClasses["ValueType"] = ValueType;
_hxClasses["ValueType"] = { __ename__ = "ValueType", __constructs__ = _hx_tab_array({[0]="TNull","TInt","TFloat","TBool","TObject","TFunction","TClass","TEnum","TUnknown"},9)}
ValueType = _hxClasses["ValueType"];
ValueType.TNull = _hx_tab_array({[0]="TNull",0,__enum__ = ValueType},2)

ValueType.TInt = _hx_tab_array({[0]="TInt",1,__enum__ = ValueType},2)

ValueType.TFloat = _hx_tab_array({[0]="TFloat",2,__enum__ = ValueType},2)

ValueType.TBool = _hx_tab_array({[0]="TBool",3,__enum__ = ValueType},2)

ValueType.TObject = _hx_tab_array({[0]="TObject",4,__enum__ = ValueType},2)

ValueType.TFunction = _hx_tab_array({[0]="TFunction",5,__enum__ = ValueType},2)

ValueType.TClass = function(c) local _x = _hx_tab_array({[0]="TClass",6,c,__enum__=ValueType}, 3); return _x; end 
ValueType.TEnum = function(e) local _x = _hx_tab_array({[0]="TEnum",7,e,__enum__=ValueType}, 3); return _x; end 
ValueType.TUnknown = _hx_tab_array({[0]="TUnknown",8,__enum__ = ValueType},2)

ValueType.__empty_constructs__ = _hx_tab_array({[0] = ValueType.TNull,ValueType.TInt,ValueType.TFloat,ValueType.TBool,ValueType.TObject,ValueType.TFunction,ValueType.TUnknown}, 7)

Type.new = {}
_hxClasses["Type"] = Type
Type.__name__ = "Type"
Type.getClass = function(o) 
  if (o == nil) then 
    do return nil end;
  end;
  local o = o;
  if (__lua_Boot.__instanceof(o, Array)) then 
    do return Array end;
  else
    if (__lua_Boot.__instanceof(o, String)) then 
      do return String end;
    else
      local cl = o.__class__;
      if (cl ~= nil) then 
        do return cl end;
      else
        do return nil end;
      end;
    end;
  end;
end
Type.getEnum = function(o) 
  if (o == nil) then 
    do return nil end;
  end;
  do return o.__enum__ end;
end
Type.getSuperClass = function(c) 
  do return c.__super__ end;
end
Type.getClassName = function(c) 
  do return c.__name__ end;
end
Type.getEnumName = function(e) 
  if (e.__ename__ == nil) then 
    do return nil end;
  end;
  do return e.__ename__ end;
end
Type.resolveClass = function(name) 
  local cl = _hxClasses[name];
  local tmp;
  if (cl ~= nil) then 
    local o = cl;
    tmp = not ((function() 
      local _hx_1
      if (__lua__Lua_Lua_Fields_.type(o) ~= "table") then 
      _hx_1 = false; else 
      _hx_1 = o.__name__; end
      return _hx_1
    end )());
  else
    tmp = true;
  end;
  if (tmp) then 
    do return nil end;
  end;
  do return cl end;
end
Type.resolveEnum = function(name) 
  local e = _hxClasses[name];
  if ((e == nil) or not ((function() 
    local _hx_1
    if (__lua__Lua_Lua_Fields_.type(e) ~= "table") then 
    _hx_1 = false; else 
    _hx_1 = e.__ename__; end
    return _hx_1
  end )())) then 
    do return nil end;
  end;
  do return e end;
end
Type.createInstance = function(cl,args) 
  do return cl.new(table.unpack(args, 0)) end;
end
Type.createEmptyInstance = function(cl) 
  local ret = ({});
  __lua__Lua_Lua_Fields_.setmetatable(ret, _hx_o({__fields__={__index=true},__index=cl.prototype}));
  do return ret end;
end
Type.createEnum = function(e,constr,params) 
  local f = Reflect.field(e, constr);
  if (f == nil) then 
    error(__haxe_Exception.thrown(Std.string("No such constructor ") .. Std.string(constr)),0);
  end;
  if (Reflect.isFunction(f)) then 
    if (params == nil) then 
      error(__haxe_Exception.thrown(Std.string(Std.string("Constructor ") .. Std.string(constr)) .. Std.string(" need parameters")),0);
    end;
    do return Reflect.callMethod(nil,f,params) end;
  end;
  if ((params ~= nil) and (params.length ~= 0)) then 
    error(__haxe_Exception.thrown(Std.string(Std.string("Constructor ") .. Std.string(constr)) .. Std.string(" does not need parameters")),0);
  end;
  do return f end;
end
Type.createEnumIndex = function(e,index,params) 
  local c = e.__constructs__[index];
  if (c == nil) then 
    error(__haxe_Exception.thrown(Std.string(index) .. Std.string(" is not a valid enum constructor index")),0);
  end;
  do return Type.createEnum(e, c, params) end;
end
Type.getInstanceFields = function(c) 
  local p = c.prototype;
  local a = _hx_tab_array({}, 0);
  while (p ~= nil) do _hx_do_first_1 = false;
    
    local _g = 0;
    local _g1 = Reflect.fields(p);
    while (_g < _g1.length) do _hx_do_first_2 = false;
      
      local f = _g1[_g];
      _g = _g + 1;
      if (not Lambda.has(a, f)) then 
        a:push(f);
      end;
    end;
    local mt = __lua__Lua_Lua_Fields_.getmetatable(p);
    if ((mt ~= nil) and (mt.__index ~= nil)) then 
      p = mt.__index;
    else
      p = nil;
    end;
  end;
  do return a end;
end
Type.getClassFields = function(c) 
  local a = Reflect.fields(c);
  a:remove("__name__");
  a:remove("__interfaces__");
  a:remove("__properties__");
  a:remove("__super__");
  a:remove("__meta__");
  a:remove("prototype");
  a:remove("new");
  do return a end;
end
Type.getEnumConstructs = function(e) 
  local a = e.__constructs__;
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = a;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
  end;
  do return _g end;
end
Type.typeof = function(v) 
  local _g = __lua__Lua_Lua_Fields_.type(v);
  if (_g) == "boolean" then 
    do return ValueType.TBool end;
  elseif (_g) == "function" then 
    if ((function() 
      local _hx_1
      if (__lua__Lua_Lua_Fields_.type(v) ~= "table") then 
      _hx_1 = false; else 
      _hx_1 = v.__name__; end
      return _hx_1
    end )() or (function() 
      local _hx_2
      if (__lua__Lua_Lua_Fields_.type(v) ~= "table") then 
      _hx_2 = false; else 
      _hx_2 = v.__ename__; end
      return _hx_2
    end )()) then 
      do return ValueType.TObject end;
    end;
    do return ValueType.TFunction end;
  elseif (_g) == "nil" then 
    do return ValueType.TNull end;
  elseif (_g) == "number" then 
    if (math.ceil(v) == (math.fmod(v, 2147483648.0))) then 
      do return ValueType.TInt end;
    end;
    do return ValueType.TFloat end;
  elseif (_g) == "string" then 
    do return ValueType.TClass(String) end;
  elseif (_g) == "table" then 
    local e = v.__enum__;
    if (e ~= nil) then 
      do return ValueType.TEnum(e) end;
    end;
    local c;
    if (__lua_Boot.__instanceof(v, Array)) then 
      c = Array;
    else
      if (__lua_Boot.__instanceof(v, String)) then 
        c = String;
      else
        local cl = v.__class__;
        c = (function() 
          local _hx_3
          if (cl ~= nil) then 
          _hx_3 = cl; else 
          _hx_3 = nil; end
          return _hx_3
        end )();
      end;
    end;
    if (c ~= nil) then 
      do return ValueType.TClass(c) end;
    end;
    do return ValueType.TObject end;else
  do return ValueType.TUnknown end; end;
end
Type.enumEq = function(a,b) 
  if (a == b) then 
    do return true end;
  end;
  local _hx_status, _hx_result = pcall(function() 
  
      if (a[0] ~= b[0]) then 
        do return false end;
      end;
      local _g = 2;
      local _g1 = a.length;
      while (_g < _g1) do _hx_do_first_1 = false;
        
        _g = _g + 1;
        local i = _g - 1;
        if (not Type.enumEq(a[i], b[i])) then 
          do return false end;
        end;
      end;
      local e = a.__enum__;
      if ((e ~= b.__enum__) or (e == nil)) then 
        do return false end;
      end;
    return _hx_pcall_default
  end)
  if not _hx_status and _hx_result == "_hx_pcall_break" then
  elseif not _hx_status then 
    local _g = _hx_result;
    do return false end;
  elseif _hx_result ~= _hx_pcall_default then
    return _hx_result
  end;
  do return true end;
end
Type.enumConstructor = function(e) 
  do return e[0] end;
end
Type.enumParameters = function(e) 
  do return e:slice(2) end;
end
Type.enumIndex = function(e) 
  do return e[1] end;
end
Type.allEnums = function(e) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = e.__empty_constructs__;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
  end;
  do return _g end;
end
_hxClasses["haxe.StackItem"] = __haxe_StackItem;
_hxClasses["haxe.StackItem"] = { __ename__ = "haxe.StackItem", __constructs__ = _hx_tab_array({[0]="CFunction","Module","FilePos","Method","LocalFunction"},5)}
__haxe_StackItem = _hxClasses["haxe.StackItem"];
__haxe_StackItem.CFunction = _hx_tab_array({[0]="CFunction",0,__enum__ = __haxe_StackItem},2)

__haxe_StackItem.Module = function(m) local _x = _hx_tab_array({[0]="Module",1,m,__enum__=__haxe_StackItem}, 3); return _x; end 
__haxe_StackItem.FilePos = function(s,file,line,column) local _x = _hx_tab_array({[0]="FilePos",2,s,file,line,column,__enum__=__haxe_StackItem}, 6); return _x; end 
__haxe_StackItem.Method = function(classname,method) local _x = _hx_tab_array({[0]="Method",3,classname,method,__enum__=__haxe_StackItem}, 4); return _x; end 
__haxe_StackItem.LocalFunction = function(v) local _x = _hx_tab_array({[0]="LocalFunction",4,v,__enum__=__haxe_StackItem}, 3); return _x; end 
__haxe_StackItem.__empty_constructs__ = _hx_tab_array({[0] = __haxe_StackItem.CFunction}, 1)

__haxe__CallStack_CallStack_Impl_.new = {}
_hxClasses["haxe._CallStack.CallStack_Impl_"] = __haxe__CallStack_CallStack_Impl_
__haxe__CallStack_CallStack_Impl_.__name__ = "haxe._CallStack.CallStack_Impl_"
__haxe__CallStack_CallStack_Impl_.__properties__ = {get_length="get_length"}
__haxe__CallStack_CallStack_Impl_.get_length = function(this1) 
  do return this1.length end;
end
__haxe__CallStack_CallStack_Impl_.callStack = function() 
  do return __haxe_NativeStackTrace.toHaxe(__haxe_NativeStackTrace.callStack()) end;
end
__haxe__CallStack_CallStack_Impl_.exceptionStack = function(fullStack) 
  if (fullStack == nil) then 
    fullStack = false;
  end;
  local eStack = __haxe_NativeStackTrace.toHaxe(__haxe_NativeStackTrace.exceptionStack());
  do return (function() 
    local _hx_1
    if (fullStack) then 
    _hx_1 = eStack; else 
    _hx_1 = __haxe__CallStack_CallStack_Impl_.subtract(eStack, __haxe__CallStack_CallStack_Impl_.callStack()); end
    return _hx_1
  end )() end;
end
__haxe__CallStack_CallStack_Impl_.toString = function(stack) 
  local b = StringBuf.new();
  local _g = 0;
  local _g1 = stack;
  while (_g < _g1.length) do _hx_do_first_1 = false;
    
    local s = _g1[_g];
    _g = _g + 1;
    local str = "\nCalled from ";
    table.insert(b.b, str);
    local b1 = b;
    b1.length = b1.length + #(str);
    __haxe__CallStack_CallStack_Impl_.itemToString(b, s);
  end;
  do return table.concat(b.b) end;
end
__haxe__CallStack_CallStack_Impl_.subtract = function(this1,stack) 
  local startIndex = -1;
  local i = -1;
  local _hx_do_first_1 = true;
  while (startIndex < 0) or _hx_do_first_1 do 
    _hx_do_first_1 = false;
    
    i = i + 1;
    if (not (i < this1.length)) then 
      break;
    end;
    local _g = 0;
    local _g1 = stack.length;
    while (_g < _g1) do _hx_do_first_2 = false;
      
      _g = _g + 1;
      local j = _g - 1;
      if (__haxe__CallStack_CallStack_Impl_.equalItems(this1[i], stack[j])) then 
        if (startIndex < 0) then 
          startIndex = i;
        end;
        i = i + 1;
        if (i >= this1.length) then 
          break;
        end;
      else
        startIndex = -1;
      end;
    end;
  end;
  if (startIndex >= 0) then 
    do return this1:slice(0, startIndex) end;
  else
    do return this1 end;
  end;
end
__haxe__CallStack_CallStack_Impl_.copy = function(this1) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = this1;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
  end;
  do return _g end;
end
__haxe__CallStack_CallStack_Impl_.get = function(this1,index) 
  do return this1[index] end;
end
__haxe__CallStack_CallStack_Impl_.asArray = function(this1) 
  do return this1 end;
end
__haxe__CallStack_CallStack_Impl_.equalItems = function(item1,item2) 
  if (item1 == nil) then 
    if (item2 == nil) then 
      do return true end;
    else
      do return false end;
    end;
  else
    local tmp = item1[1];
    if (tmp) == 0 then 
      if (item2 == nil) then 
        do return false end;
      else
        if (item2[1] == 0) then 
          do return true end;
        else
          do return false end;
        end;
      end;
    elseif (tmp) == 1 then 
      if (item2 == nil) then 
        do return false end;
      else
        if (item2[1] == 1) then 
          local m2 = item2[2];
          local m1 = item1[2];
          do return m1 == m2 end;
        else
          do return false end;
        end;
      end;
    elseif (tmp) == 2 then 
      if (item2 == nil) then 
        do return false end;
      else
        if (item2[1] == 2) then 
          local item21 = item2[2];
          local file2 = item2[3];
          local line2 = item2[4];
          local col2 = item2[5];
          local col1 = item1[5];
          local line1 = item1[4];
          local file1 = item1[3];
          local item1 = item1[2];
          if (((file1 == file2) and (line1 == line2)) and (col1 == col2)) then 
            do return __haxe__CallStack_CallStack_Impl_.equalItems(item1, item21) end;
          else
            do return false end;
          end;
        else
          do return false end;
        end;
      end;
    elseif (tmp) == 3 then 
      if (item2 == nil) then 
        do return false end;
      else
        if (item2[1] == 3) then 
          local class2 = item2[2];
          local method2 = item2[3];
          local method1 = item1[3];
          local class1 = item1[2];
          if (class1 == class2) then 
            do return method1 == method2 end;
          else
            do return false end;
          end;
        else
          do return false end;
        end;
      end;
    elseif (tmp) == 4 then 
      if (item2 == nil) then 
        do return false end;
      else
        if (item2[1] == 4) then 
          local v2 = item2[2];
          local v1 = item1[2];
          do return v1 == v2 end;
        else
          do return false end;
        end;
      end; end;
  end;
end
__haxe__CallStack_CallStack_Impl_.exceptionToString = function(e) 
  if (e:get_previous() == nil) then 
    local tmp = Std.string("Exception: ") .. Std.string(e:toString());
    local tmp1 = e:get_stack();
    do return Std.string(tmp) .. Std.string(((function() 
      local _hx_1
      if (tmp1 == nil) then 
      _hx_1 = "null"; else 
      _hx_1 = _hx_wrap_if_string_field(__haxe__CallStack_CallStack_Impl_,'toString')(tmp1); end
      return _hx_1
    end )())) end;
  end;
  local result = "";
  local e = e;
  local prev = nil;
  while (e ~= nil) do _hx_do_first_1 = false;
    
    if (prev == nil) then 
      local result1 = Std.string("Exception: ") .. Std.string(e:get_message());
      local tmp = e:get_stack();
      result = Std.string(Std.string(result1) .. Std.string(((function() 
        local _hx_2
        if (tmp == nil) then 
        _hx_2 = "null"; else 
        _hx_2 = _hx_wrap_if_string_field(__haxe__CallStack_CallStack_Impl_,'toString')(tmp); end
        return _hx_2
      end )()))) .. Std.string(result);
    else
      local prevStack = __haxe__CallStack_CallStack_Impl_.subtract(e:get_stack(), prev:get_stack());
      result = Std.string(Std.string(Std.string(Std.string("Exception: ") .. Std.string(e:get_message())) .. Std.string(((function() 
        local _hx_3
        if (prevStack == nil) then 
        _hx_3 = "null"; else 
        _hx_3 = _hx_wrap_if_string_field(__haxe__CallStack_CallStack_Impl_,'toString')(prevStack); end
        return _hx_3
      end )()))) .. Std.string("\n\nNext ")) .. Std.string(result);
    end;
    prev = e;
    e = e:get_previous();
  end;
  do return result end;
end
__haxe__CallStack_CallStack_Impl_.itemToString = function(b,s) 
  local tmp = s[1];
  if (tmp) == 0 then 
    local str = "a C function";
    table.insert(b.b, str);
    local b = b;
    b.length = b.length + #(str);
  elseif (tmp) == 1 then 
    local m = s[2];
    local str = "module ";
    table.insert(b.b, str);
    local b1 = b;
    b1.length = b1.length + #(str);
    local str = Std.string(m);
    table.insert(b.b, str);
    local b = b;
    b.length = b.length + #(str);
  elseif (tmp) == 2 then 
    local s1 = s[2];
    local file = s[3];
    local line = s[4];
    local col = s[5];
    if (s1 ~= nil) then 
      __haxe__CallStack_CallStack_Impl_.itemToString(b, s1);
      local str = " (";
      table.insert(b.b, str);
      local b = b;
      b.length = b.length + #(str);
    end;
    local str = Std.string(file);
    table.insert(b.b, str);
    local b1 = b;
    b1.length = b1.length + #(str);
    local str = " line ";
    table.insert(b.b, str);
    local b1 = b;
    b1.length = b1.length + #(str);
    local str = Std.string(line);
    table.insert(b.b, str);
    local b1 = b;
    b1.length = b1.length + #(str);
    if (col ~= nil) then 
      local str = " column ";
      table.insert(b.b, str);
      local b1 = b;
      b1.length = b1.length + #(str);
      local str = Std.string(col);
      table.insert(b.b, str);
      local b = b;
      b.length = b.length + #(str);
    end;
    if (s1 ~= nil) then 
      local str = ")";
      table.insert(b.b, str);
      local b = b;
      b.length = b.length + #(str);
    end;
  elseif (tmp) == 3 then 
    local cname = s[2];
    local meth = s[3];
    local str = Std.string((function() 
      local _hx_1
      if (cname == nil) then 
      _hx_1 = "<unknown>"; else 
      _hx_1 = cname; end
      return _hx_1
    end )());
    table.insert(b.b, str);
    local b1 = b;
    b1.length = b1.length + #(str);
    local str = ".";
    table.insert(b.b, str);
    local b1 = b;
    b1.length = b1.length + #(str);
    local str = Std.string(meth);
    table.insert(b.b, str);
    local b = b;
    b.length = b.length + #(str);
  elseif (tmp) == 4 then 
    local n = s[2];
    local str = "local function #";
    table.insert(b.b, str);
    local b1 = b;
    b1.length = b1.length + #(str);
    local str = Std.string(n);
    table.insert(b.b, str);
    local b = b;
    b.length = b.length + #(str); end;
end

__haxe_IMap.new = {}
_hxClasses["haxe.IMap"] = __haxe_IMap
__haxe_IMap.__name__ = "haxe.IMap"
__haxe_IMap.prototype = _hx_e();
__haxe_IMap.prototype.get= nil;
__haxe_IMap.prototype.set= nil;
__haxe_IMap.prototype.exists= nil;
__haxe_IMap.prototype.remove= nil;
__haxe_IMap.prototype.keys= nil;
__haxe_IMap.prototype.iterator= nil;
__haxe_IMap.prototype.keyValueIterator= nil;
__haxe_IMap.prototype.copy= nil;
__haxe_IMap.prototype.toString= nil;
__haxe_IMap.prototype.clear= nil;

__haxe_IMap.prototype.__class__ =  __haxe_IMap

__haxe_Exception.new = function(message,previous,native) 
  local self = _hx_new(__haxe_Exception.prototype)
  __haxe_Exception.super(self,message,previous,native)
  return self
end
__haxe_Exception.super = function(self,message,previous,native) 
  self.__skipStack = 0;
  self.__exceptionMessage = message;
  self.__previousException = previous;
  if (native ~= nil) then 
    self.__nativeException = native;
    self.__nativeStack = __haxe_NativeStackTrace.exceptionStack();
  else
    self.__nativeException = self;
    self.__nativeStack = __haxe_NativeStackTrace.callStack();
    self.__skipStack = 1;
  end;
end
_hxClasses["haxe.Exception"] = __haxe_Exception
__haxe_Exception.__name__ = "haxe.Exception"
__haxe_Exception.caught = function(value) 
  if (__lua_Boot.__instanceof(value, __haxe_Exception)) then 
    do return value end;
  else
    do return __haxe_ValueException.new(value, nil, value) end;
  end;
end
__haxe_Exception.thrown = function(value) 
  if (__lua_Boot.__instanceof(value, __haxe_Exception)) then 
    do return value:get_native() end;
  else
    local e = __haxe_ValueException.new(value);
    e.__skipStack = e.__skipStack + 1;
    do return e end;
  end;
end
__haxe_Exception.prototype = _hx_e();
__haxe_Exception.prototype.__exceptionMessage= nil;
__haxe_Exception.prototype.__exceptionStack= nil;
__haxe_Exception.prototype.__nativeStack= nil;
__haxe_Exception.prototype.__skipStack= nil;
__haxe_Exception.prototype.__nativeException= nil;
__haxe_Exception.prototype.__previousException= nil;
__haxe_Exception.prototype.unwrap = function(self) 
  do return self.__nativeException end
end
__haxe_Exception.prototype.toString = function(self) 
  do return self:get_message() end
end
__haxe_Exception.prototype.details = function(self) 
  if (self:get_previous() == nil) then 
    local tmp = Std.string("Exception: ") .. Std.string(self:toString());
    local tmp1 = self:get_stack();
    do return Std.string(tmp) .. Std.string(((function() 
      local _hx_1
      if (tmp1 == nil) then 
      _hx_1 = "null"; else 
      _hx_1 = _hx_wrap_if_string_field(__haxe__CallStack_CallStack_Impl_,'toString')(tmp1); end
      return _hx_1
    end )())) end;
  else
    local result = "";
    local e = self;
    local prev = nil;
    while (e ~= nil) do _hx_do_first_1 = false;
      
      if (prev == nil) then 
        local result1 = Std.string("Exception: ") .. Std.string(e:get_message());
        local tmp = e:get_stack();
        result = Std.string(Std.string(result1) .. Std.string(((function() 
          local _hx_2
          if (tmp == nil) then 
          _hx_2 = "null"; else 
          _hx_2 = _hx_wrap_if_string_field(__haxe__CallStack_CallStack_Impl_,'toString')(tmp); end
          return _hx_2
        end )()))) .. Std.string(result);
      else
        local prevStack = __haxe__CallStack_CallStack_Impl_.subtract(e:get_stack(), prev:get_stack());
        result = Std.string(Std.string(Std.string(Std.string("Exception: ") .. Std.string(e:get_message())) .. Std.string(((function() 
          local _hx_3
          if (prevStack == nil) then 
          _hx_3 = "null"; else 
          _hx_3 = _hx_wrap_if_string_field(__haxe__CallStack_CallStack_Impl_,'toString')(prevStack); end
          return _hx_3
        end )()))) .. Std.string("\n\nNext ")) .. Std.string(result);
      end;
      prev = e;
      e = e:get_previous();
    end;
    do return result end;
  end;
end
__haxe_Exception.prototype.__shiftStack = function(self) 
  self.__skipStack = self.__skipStack + 1;
end
__haxe_Exception.prototype.get_message = function(self) 
  do return self.__exceptionMessage end
end
__haxe_Exception.prototype.get_previous = function(self) 
  do return self.__previousException end
end
__haxe_Exception.prototype.get_native = function(self) 
  do return self.__nativeException end
end
__haxe_Exception.prototype.get_stack = function(self) 
  local _g = self.__exceptionStack;
  if (_g == nil) then 
    self.__exceptionStack = __haxe_NativeStackTrace.toHaxe(self.__nativeStack, self.__skipStack) do return self.__exceptionStack end;
  else
    local s = _g;
    do return s end;
  end;
end

__haxe_Exception.prototype.__class__ =  __haxe_Exception

__haxe_Exception.prototype.__properties__ =  {get_native="get_native",get_previous="get_previous",get_stack="get_stack",get_message="get_message"}

__haxe_Json.new = {}
_hxClasses["haxe.Json"] = __haxe_Json
__haxe_Json.__name__ = "haxe.Json"
__haxe_Json.parse = function(text) 
  do return __haxe_format_JsonParser.new(text):doParse() end;
end
__haxe_Json.stringify = function(value,replacer,space) 
  do return __haxe_format_JsonPrinter.print(value, replacer, space) end;
end

__haxe_Log.new = {}
_hxClasses["haxe.Log"] = __haxe_Log
__haxe_Log.__name__ = "haxe.Log"
__haxe_Log.formatOutput = function(v,infos) 
  local str = Std.string(v);
  if (infos == nil) then 
    do return str end;
  end;
  local pstr = Std.string(Std.string(infos.fileName) .. Std.string(":")) .. Std.string(infos.lineNumber);
  if (infos.customParams ~= nil) then 
    local _g = 0;
    local _g1 = infos.customParams;
    while (_g < _g1.length) do _hx_do_first_1 = false;
      
      local v = _g1[_g];
      _g = _g + 1;
      str = Std.string(str) .. Std.string((Std.string(", ") .. Std.string(Std.string(v))));
    end;
  end;
  do return Std.string(Std.string(pstr) .. Std.string(": ")) .. Std.string(str) end;
end
__haxe_Log.trace = function(v,infos) 
  local str = __haxe_Log.formatOutput(v, infos);
  print(str);
end

__haxe_NativeStackTrace.new = {}
_hxClasses["haxe.NativeStackTrace"] = __haxe_NativeStackTrace
__haxe_NativeStackTrace.__name__ = "haxe.NativeStackTrace"
__haxe_NativeStackTrace.saveStack = function(exception) 
end
__haxe_NativeStackTrace.callStack = function() 
  local _g = debug.traceback();
  if (_g == nil) then 
    do return _hx_tab_array({}, 0) end;
  else
    local s = _g;
    do return String.prototype.split(s, "\n"):slice(3) end;
  end;
end
__haxe_NativeStackTrace.exceptionStack = function() 
  do return _hx_tab_array({}, 0) end;
end
__haxe_NativeStackTrace.toHaxe = function(native,skip) 
  if (skip == nil) then 
    skip = 0;
  end;
  local stack = _hx_tab_array({}, 0);
  local cnt = -1;
  local _g = 0;
  local _hx_continue_1 = false;
  while (_g < native.length) do _hx_do_first_1 = false;
    repeat 
    local item = native[_g];
    _g = _g + 1;
    local parts = String.prototype.split(String.prototype.substr(item, 1), ":");
    local file = parts[0];
    if (file == "[C]") then 
      break;
    end;
    cnt = cnt + 1;
    if (skip > cnt) then 
      break;
    end;
    local line = parts[1];
    local method;
    if (parts.length <= 2) then 
      method = nil;
    else
      local methodPos = String.prototype.indexOf(parts[2], "'");
      method = (function() 
        local _hx_1
        if (methodPos < 0) then 
        _hx_1 = nil; else 
        _hx_1 = __haxe_StackItem.Method(nil, String.prototype.substring(parts[2], methodPos + 1, #(parts[2]) - 1)); end
        return _hx_1
      end )();
    end;
    stack:push(__haxe_StackItem.FilePos(method, file, Std.parseInt(line)));until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
  do return stack end;
end

__haxe__Rest_Rest_Impl_.new = {}
_hxClasses["haxe._Rest.Rest_Impl_"] = __haxe__Rest_Rest_Impl_
__haxe__Rest_Rest_Impl_.__name__ = "haxe._Rest.Rest_Impl_"
__haxe__Rest_Rest_Impl_.__properties__ = {get_length="get_length"}
__haxe__Rest_Rest_Impl_.get_length = function(this1) 
  do return table.maxn(this1) end;
end
__haxe__Rest_Rest_Impl_.of = function(array) 
  local ret = {};
  local _g = 0;
  local _g1 = array.length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local idx = _g - 1;
    ret[idx + 1] = array[idx];
  end;
  do return ret end;
end
__haxe__Rest_Rest_Impl_._new = function(table) 
  do return table end;
end
__haxe__Rest_Rest_Impl_.get = function(this1,index) 
  do return this1[index + 1] end;
end
__haxe__Rest_Rest_Impl_.toArray = function(this1) 
  local length = nil;
  local tab = __lua_PairTools.copy(this1);
  local length = length;
  if (length == nil) then 
    length = table.maxn(tab);
    if (length > 0) then 
      local head = tab[1];
      table.remove(tab, 1);
      tab[0] = head;
      do return _hx_tab_array(tab, length) end;
    else
      do return _hx_tab_array({}, 0) end;
    end;
  else
    do return _hx_tab_array(tab, length) end;
  end;
end
__haxe__Rest_Rest_Impl_.iterator = function(this1) 
  do return __haxe_iterators_RestIterator.new(this1) end;
end
__haxe__Rest_Rest_Impl_.keyValueIterator = function(this1) 
  do return __haxe_iterators_RestKeyValueIterator.new(this1) end;
end
__haxe__Rest_Rest_Impl_.append = function(this1,item) 
  local result = __lua_PairTools.copy(this1);
  table.insert(result, item);
  do return result end;
end
__haxe__Rest_Rest_Impl_.prepend = function(this1,item) 
  local result = __lua_PairTools.copy(this1);
  table.insert(result, 1, item);
  do return result end;
end
__haxe__Rest_Rest_Impl_.toString = function(this1) 
  do return __haxe__Rest_Rest_Impl_.toArray(this1):toString() end;
end
_hxClasses["haxe._Template.TemplateExpr"] = __haxe__Template_TemplateExpr;
_hxClasses["haxe._Template.TemplateExpr"] = { __ename__ = "haxe._Template.TemplateExpr", __constructs__ = _hx_tab_array({[0]="OpVar","OpExpr","OpIf","OpStr","OpBlock","OpForeach","OpMacro"},7)}
__haxe__Template_TemplateExpr = _hxClasses["haxe._Template.TemplateExpr"];
__haxe__Template_TemplateExpr.OpVar = function(v) local _x = _hx_tab_array({[0]="OpVar",0,v,__enum__=__haxe__Template_TemplateExpr}, 3); return _x; end 
__haxe__Template_TemplateExpr.OpExpr = function(expr) local _x = _hx_tab_array({[0]="OpExpr",1,expr,__enum__=__haxe__Template_TemplateExpr}, 3); return _x; end 
__haxe__Template_TemplateExpr.OpIf = function(expr,eif,eelse) local _x = _hx_tab_array({[0]="OpIf",2,expr,eif,eelse,__enum__=__haxe__Template_TemplateExpr}, 5); return _x; end 
__haxe__Template_TemplateExpr.OpStr = function(str) local _x = _hx_tab_array({[0]="OpStr",3,str,__enum__=__haxe__Template_TemplateExpr}, 3); return _x; end 
__haxe__Template_TemplateExpr.OpBlock = function(l) local _x = _hx_tab_array({[0]="OpBlock",4,l,__enum__=__haxe__Template_TemplateExpr}, 3); return _x; end 
__haxe__Template_TemplateExpr.OpForeach = function(expr,loop) local _x = _hx_tab_array({[0]="OpForeach",5,expr,loop,__enum__=__haxe__Template_TemplateExpr}, 4); return _x; end 
__haxe__Template_TemplateExpr.OpMacro = function(name,params) local _x = _hx_tab_array({[0]="OpMacro",6,name,params,__enum__=__haxe__Template_TemplateExpr}, 4); return _x; end 
__haxe__Template_TemplateExpr.__empty_constructs__ = _hx_tab_array({}, 0)

__haxe_iterators_ArrayIterator.new = function(array) 
  local self = _hx_new(__haxe_iterators_ArrayIterator.prototype)
  __haxe_iterators_ArrayIterator.super(self,array)
  return self
end
__haxe_iterators_ArrayIterator.super = function(self,array) 
  self.current = 0;
  self.array = array;
end
_hxClasses["haxe.iterators.ArrayIterator"] = __haxe_iterators_ArrayIterator
__haxe_iterators_ArrayIterator.__name__ = "haxe.iterators.ArrayIterator"
__haxe_iterators_ArrayIterator.prototype = _hx_e();
__haxe_iterators_ArrayIterator.prototype.array= nil;
__haxe_iterators_ArrayIterator.prototype.current= nil;
__haxe_iterators_ArrayIterator.prototype.hasNext = function(self) 
  do return self.current < self.array.length end
end
__haxe_iterators_ArrayIterator.prototype.next = function(self) 
  do return self.array[(function() 
  local _hx_obj = self;
  local _hx_fld = 'current';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)()] end
end

__haxe_iterators_ArrayIterator.prototype.__class__ =  __haxe_iterators_ArrayIterator

__haxe_Template.new = function(str) 
  local self = _hx_new(__haxe_Template.prototype)
  __haxe_Template.super(self,str)
  return self
end
__haxe_Template.super = function(self,str) 
  local tokens = self:parseTokens(str);
  self.expr = self:parseBlock(tokens);
  if (not tokens:isEmpty()) then 
    error(__haxe_Exception.thrown(Std.string(Std.string("Unexpected '") .. Std.string(Std.string(tokens:first().s))) .. Std.string("'")),0);
  end;
end
_hxClasses["haxe.Template"] = __haxe_Template
__haxe_Template.__name__ = "haxe.Template"
__haxe_Template.prototype = _hx_e();
__haxe_Template.prototype.expr= nil;
__haxe_Template.prototype.context= nil;
__haxe_Template.prototype.macros= nil;
__haxe_Template.prototype.stack= nil;
__haxe_Template.prototype.buf= nil;
__haxe_Template.prototype.execute = function(self,context,macros) 
  self.macros = (function() 
    local _hx_1
    if (macros == nil) then 
    _hx_1 = _hx_e(); else 
    _hx_1 = macros; end
    return _hx_1
  end )();
  self.context = context;
  self.stack = __haxe_ds_List.new();
  self.buf = StringBuf.new();
  self:run(self.expr);
  do return table.concat(self.buf.b) end
end
__haxe_Template.prototype.resolve = function(self,v) 
  if (v == "__current__") then 
    do return self.context end;
  end;
  if (Reflect.isObject(self.context)) then 
    local value = Reflect.getProperty(self.context, v);
    local tmp;
    if (value == nil) then 
      local o = self.context;
      tmp = (function() 
        local _hx_1
        if ((__lua__Lua_Lua_Fields_.type(o) == "function") and not ((function() 
          local _hx_2
          if (__lua__Lua_Lua_Fields_.type(o) ~= "table") then 
          _hx_2 = false; else 
          _hx_2 = o.__name__; end
          return _hx_2
        end )() or (function() 
          local _hx_3
          if (__lua__Lua_Lua_Fields_.type(o) ~= "table") then 
          _hx_3 = false; else 
          _hx_3 = o.__ename__; end
          return _hx_3
        end )())) then 
        _hx_1 = false; elseif ((__lua__Lua_Lua_Fields_.type(o) == "string") and ((String.prototype[v] ~= nil) or (v == "length"))) then 
        _hx_1 = true; elseif (o.__fields__ ~= nil) then 
        _hx_1 = o.__fields__[v] ~= nil; else 
        _hx_1 = o[v] ~= nil; end
        return _hx_1
      end )();
    else
      tmp = true;
    end;
    if (tmp) then 
      do return value end;
    end;
  end;
  local _g_head = self.stack.h;
  while (_g_head ~= nil) do _hx_do_first_1 = false;
    
    local val = _g_head.item;
    _g_head = _g_head.next;
    local ctx = val;
    local value = Reflect.getProperty(ctx, v);
    local tmp;
    if (value == nil) then 
      local o = ctx;
      tmp = (function() 
        local _hx_4
        if ((__lua__Lua_Lua_Fields_.type(o) == "function") and not ((function() 
          local _hx_5
          if (__lua__Lua_Lua_Fields_.type(o) ~= "table") then 
          _hx_5 = false; else 
          _hx_5 = o.__name__; end
          return _hx_5
        end )() or (function() 
          local _hx_6
          if (__lua__Lua_Lua_Fields_.type(o) ~= "table") then 
          _hx_6 = false; else 
          _hx_6 = o.__ename__; end
          return _hx_6
        end )())) then 
        _hx_4 = false; elseif ((__lua__Lua_Lua_Fields_.type(o) == "string") and ((String.prototype[v] ~= nil) or (v == "length"))) then 
        _hx_4 = true; elseif (o.__fields__ ~= nil) then 
        _hx_4 = o.__fields__[v] ~= nil; else 
        _hx_4 = o[v] ~= nil; end
        return _hx_4
      end )();
    else
      tmp = true;
    end;
    if (tmp) then 
      do return value end;
    end;
  end;
  do return Reflect.field(__haxe_Template.globals, v) end
end
__haxe_Template.prototype.parseTokens = function(self,data) 
  local tokens = __haxe_ds_List.new();
  local _hx_continue_1 = false;
  while (__haxe_Template.splitter:match(data)) do _hx_do_first_1 = false;
    repeat 
    local p = __haxe_Template.splitter:matchedPos();
    if (p.pos > 0) then 
      tokens:add(_hx_o({__fields__={p=true,s=true,l=true},p=String.prototype.substr(data, 0, p.pos),s=true,l=nil}));
    end;
    if (string.byte(data, p.pos + 1) == 58) then 
      tokens:add(_hx_o({__fields__={p=true,s=true,l=true},p=String.prototype.substr(data, p.pos + 2, p.len - 4),s=false,l=nil}));
      data = __haxe_Template.splitter:matchedRight();
      break;
    end;
    local parp = p.pos + p.len;
    local npar = 1;
    local params = _hx_tab_array({}, 0);
    local part = "";
    while (true) do _hx_do_first_2 = false;
      
      local c = string.byte(data, parp + 1);
      parp = parp + 1;
      if (c == 40) then 
        npar = npar + 1;
      else
        if (c == 41) then 
          npar = npar - 1;
          if (npar <= 0) then 
            break;
          end;
        else
          if (c == nil) then 
            error(__haxe_Exception.thrown("Unclosed macro parenthesis"),0);
          end;
        end;
      end;
      if ((c == 44) and (npar == 1)) then 
        params:push(part);
        part = "";
      else
        part = Std.string(part) .. Std.string(string.char(c));
      end;
    end;
    params:push(part);
    tokens:add(_hx_o({__fields__={p=true,s=true,l=true},p=__haxe_Template.splitter:matched(2),s=false,l=params}));
    data = String.prototype.substr(data, parp, #(data) - parp);until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
  if (#(data) > 0) then 
    tokens:add(_hx_o({__fields__={p=true,s=true,l=true},p=data,s=true,l=nil}));
  end;
  do return tokens end
end
__haxe_Template.prototype.parseBlock = function(self,tokens) 
  local l = __haxe_ds_List.new();
  while (true) do _hx_do_first_1 = false;
    
    local t = tokens:first();
    if (t == nil) then 
      break;
    end;
    if (not t.s and (((t.p == "end") or (t.p == "else")) or (String.prototype.substr(t.p, 0, 7) == "elseif "))) then 
      break;
    end;
    l:add(self:parse(tokens));
  end;
  if (l.length == 1) then 
    do return l:first() end;
  end;
  do return __haxe__Template_TemplateExpr.OpBlock(l) end
end
__haxe_Template.prototype.parse = function(self,tokens) 
  local t = tokens:pop();
  local p = t.p;
  if (t.s) then 
    do return __haxe__Template_TemplateExpr.OpStr(p) end;
  end;
  if (t.l ~= nil) then 
    local pe = __haxe_ds_List.new();
    local _g = 0;
    local _g1 = t.l;
    while (_g < _g1.length) do _hx_do_first_1 = false;
      
      local p = _g1[_g];
      _g = _g + 1;
      pe:add(self:parseBlock(self:parseTokens(p)));
    end;
    do return __haxe__Template_TemplateExpr.OpMacro(p, pe) end;
  end;
  local kwdEnd = function(kwd) 
    local pos = -1;
    local length = #(kwd);
    if (String.prototype.substr(p, 0, length) == kwd) then 
      pos = length;
      local s = String.prototype.substr(p, length);
      local _g_codes = utf8.codes(s);
      local _g_str = s;
      local _hx_1_cp_position, _hx_1_cp_codepoint = _g_codes(_g_str, 0);
      local _g_codepoint = _hx_1_cp_codepoint;
      local _g_position = _hx_1_cp_position;
      while (_g_codepoint ~= nil) do _hx_do_first_1 = false;
        
        local ret = _g_codepoint;
        local _hx_2_cp_position, _hx_2_cp_codepoint = _g_codes(_g_str, _g_position);
        _g_codepoint = _hx_2_cp_codepoint;
        _g_position = _hx_2_cp_position;
        local c = ret;
        if (c == 32) then 
          pos = pos + 1;
        else
          break;
        end;
      end;
    end;
    do return pos end;
  end;
  local pos = kwdEnd("if");
  if (pos > 0) then 
    p = String.prototype.substr(p, pos, #(p) - pos);
    local e = self:parseExpr(p);
    local eif = self:parseBlock(tokens);
    local t = tokens:first();
    local eelse;
    if (t == nil) then 
      error(__haxe_Exception.thrown("Unclosed 'if'"),0);
    end;
    if (t.p == "end") then 
      tokens:pop();
      eelse = nil;
    else
      if (t.p == "else") then 
        tokens:pop();
        eelse = self:parseBlock(tokens);
        t = tokens:pop();
        if ((t == nil) or (t.p ~= "end")) then 
          error(__haxe_Exception.thrown("Unclosed 'else'"),0);
        end;
      else
        t.p = String.prototype.substr(t.p, 4, #(t.p) - 4);
        eelse = self:parse(tokens);
      end;
    end;
    do return __haxe__Template_TemplateExpr.OpIf(e, eif, eelse) end;
  end;
  local pos = kwdEnd("foreach");
  if (pos >= 0) then 
    p = String.prototype.substr(p, pos, #(p) - pos);
    local e = self:parseExpr(p);
    local efor = self:parseBlock(tokens);
    local t = tokens:pop();
    if ((t == nil) or (t.p ~= "end")) then 
      error(__haxe_Exception.thrown("Unclosed 'foreach'"),0);
    end;
    do return __haxe__Template_TemplateExpr.OpForeach(e, efor) end;
  end;
  if (__haxe_Template.expr_splitter:match(p)) then 
    do return __haxe__Template_TemplateExpr.OpExpr(self:parseExpr(p)) end;
  end;
  do return __haxe__Template_TemplateExpr.OpVar(p) end
end
__haxe_Template.prototype.parseExpr = function(self,data) 
  local l = __haxe_ds_List.new();
  local expr = data;
  while (__haxe_Template.expr_splitter:match(data)) do _hx_do_first_1 = false;
    
    local p = __haxe_Template.expr_splitter:matchedPos();
    local k = p.pos + p.len;
    if (p.pos ~= 0) then 
      l:add(_hx_o({__fields__={p=true,s=true},p=String.prototype.substr(data, 0, p.pos),s=true}));
    end;
    local p = __haxe_Template.expr_splitter:matched(0);
    l:add(_hx_o({__fields__={p=true,s=true},p=p,s=String.prototype.indexOf(p, "\"") >= 0}));
    data = __haxe_Template.expr_splitter:matchedRight();
  end;
  if (#(data) ~= 0) then 
    local _g_offset = 0;
    local _g_s = data;
    while (_g_offset < #(_g_s)) do _hx_do_first_1 = false;
      
      local _g_key = _g_offset;
      _g_offset = _g_offset + 1;
      local _g_value = string.byte(_g_s, (_g_offset - 1) + 1);
      local i = _g_key;
      local c = _g_value;
      if (c ~= 32) then 
        l:add(_hx_o({__fields__={p=true,s=true},p=String.prototype.substr(data, i),s=true}));
        break;
      end;
    end;
  end;
  local e;
  local _hx_status, _hx_result = pcall(function() 
  
      e = self:makeExpr(l);
      if (not l:isEmpty()) then 
        error(__haxe_Exception.thrown(l:first().p),0);
      end;
    return _hx_pcall_default
  end)
  if not _hx_status and _hx_result == "_hx_pcall_break" then
  elseif not _hx_status then 
    local _g = _hx_result;
    local _g1 = __haxe_Exception.caught(_g):unwrap();
    if (__lua_Boot.__instanceof(_g1, String)) then 
      local s = _g1;
      error(__haxe_Exception.thrown(Std.string(Std.string(Std.string("Unexpected '") .. Std.string(s)) .. Std.string("' in ")) .. Std.string(expr)),0);
    else
      error(_g,0);
    end;
  elseif _hx_result ~= _hx_pcall_default then
    return _hx_result
  end;
  do return function() 
    local _hx_status, _hx_result = pcall(function() 
    
        do return e() end;
      return _hx_pcall_default
    end)
    if not _hx_status and _hx_result == "_hx_pcall_break" then
    elseif not _hx_status then 
      local _g = _hx_result;
      local exc = __haxe_Exception.caught(_g):unwrap();
      error(__haxe_Exception.thrown(Std.string(Std.string(Std.string("Error : ") .. Std.string(Std.string(exc))) .. Std.string(" in ")) .. Std.string(expr)),0);
    elseif _hx_result ~= _hx_pcall_default then
      return _hx_result
    end;
  end end
end
__haxe_Template.prototype.makeConst = function(self,v) 
  __haxe_Template.expr_trim:match(v);
  v = __haxe_Template.expr_trim:matched(1);
  if (string.byte(v, 1) == 34) then 
    local str = String.prototype.substr(v, 1, #(v) - 2);
    do return function() 
      do return str end;
    end end;
  end;
  if (__haxe_Template.expr_int:match(v)) then 
    local i = Std.parseInt(v);
    do return function() 
      do return i end;
    end end;
  end;
  if (__haxe_Template.expr_float:match(v)) then 
    local f = Std.parseFloat(v);
    do return function() 
      do return f end;
    end end;
  end;
  local me = self;
  do return function() 
    do return me:resolve(v) end;
  end end
end
__haxe_Template.prototype.makePath = function(self,e,l) 
  local p = l:first();
  if ((p == nil) or (p.p ~= ".")) then 
    do return e end;
  end;
  l:pop();
  local field = l:pop();
  if ((field == nil) or not field.s) then 
    error(__haxe_Exception.thrown(field.p),0);
  end;
  local f = field.p;
  __haxe_Template.expr_trim:match(f);
  f = __haxe_Template.expr_trim:matched(1);
  do return self:makePath(function() 
    do return Reflect.field(e(), f) end;
  end, l) end
end
__haxe_Template.prototype.makeExpr = function(self,l) 
  do return self:makePath(self:makeExpr2(l), l) end
end
__haxe_Template.prototype.skipSpaces = function(self,l) 
  local p = l:first();
  while (p ~= nil) do _hx_do_first_1 = false;
    
    local s = p.p;
    local _g_codes = utf8.codes(s);
    local _g_str = s;
    local _hx_1_cp_position, _hx_1_cp_codepoint = _g_codes(_g_str, 0);
    local _g_codepoint = _hx_1_cp_codepoint;
    local _g_position = _hx_1_cp_position;
    while (_g_codepoint ~= nil) do _hx_do_first_2 = false;
      
      local ret = _g_codepoint;
      local _hx_2_cp_position, _hx_2_cp_codepoint = _g_codes(_g_str, _g_position);
      _g_codepoint = _hx_2_cp_codepoint;
      _g_position = _hx_2_cp_position;
      local c = ret;
      if (c ~= 32) then 
        do return end;
      end;
    end;
    l:pop();
    p = l:first();
  end;
end
__haxe_Template.prototype.makeExpr2 = function(self,l) 
  self:skipSpaces(l);
  local p = l:pop();
  self:skipSpaces(l);
  if (p == nil) then 
    error(__haxe_Exception.thrown("<eof>"),0);
  end;
  if (p.s) then 
    do return self:makeConst(p.p) end;
  end;
  local _g = p.p;
  if (_g) == "!" then 
    local e = self:makeExpr(l);
    do return function() 
      local v = e();
      if (v ~= nil) then 
        do return v == false end;
      else
        do return true end;
      end;
    end end;
  elseif (_g) == "(" then 
    self:skipSpaces(l);
    local e1 = self:makeExpr(l);
    self:skipSpaces(l);
    local p = l:pop();
    if ((p == nil) or p.s) then 
      error(__haxe_Exception.thrown(p),0);
    end;
    if (p.p == ")") then 
      do return e1 end;
    end;
    self:skipSpaces(l);
    local e2 = self:makeExpr(l);
    self:skipSpaces(l);
    local p2 = l:pop();
    self:skipSpaces(l);
    if ((p2 == nil) or (p2.p ~= ")")) then 
      error(__haxe_Exception.thrown(p2),0);
    end;
    local _g = p.p;
    if (_g) == "!=" then 
      do return function() 
        do return e1() ~= e2() end;
      end end;
    elseif (_g) == "&&" then 
      do return function() 
        do return e1() and e2() end;
      end end;
    elseif (_g) == "*" then 
      do return function() 
        do return e1() * e2() end;
      end end;
    elseif (_g) == "+" then 
      do return function() 
        do return _hx_dyn_add(e1(),e2()) end;
      end end;
    elseif (_g) == "-" then 
      do return function() 
        do return e1() - e2() end;
      end end;
    elseif (_g) == "/" then 
      do return function() 
        do return e1() / e2() end;
      end end;
    elseif (_g) == "<" then 
      do return function() 
        do return e1() < e2() end;
      end end;
    elseif (_g) == "<=" then 
      do return function() 
        do return e1() <= e2() end;
      end end;
    elseif (_g) == "==" then 
      do return function() 
        do return e1() == e2() end;
      end end;
    elseif (_g) == ">" then 
      do return function() 
        do return e1() > e2() end;
      end end;
    elseif (_g) == ">=" then 
      do return function() 
        do return e1() >= e2() end;
      end end;
    elseif (_g) == "||" then 
      do return function() 
        do return e1() or e2() end;
      end end;else
    error(__haxe_Exception.thrown(Std.string("Unknown operation ") .. Std.string(p.p)),0); end;
  elseif (_g) == "-" then 
    local e = self:makeExpr(l);
    do return function() 
      do return -e() end;
    end end; end;
  error(__haxe_Exception.thrown(p.p),0);
end
__haxe_Template.prototype.run = function(self,e) 
  local tmp = e[1];
  if (tmp) == 0 then 
    local v = e[2];
    local _this = self.buf;
    local str = Std.string(self:resolve(v));
    table.insert(_this.b, str);
    local _this = _this;
    _this.length = _this.length + #(str);
  elseif (tmp) == 1 then 
    local e = e[2];
    local _this = self.buf;
    local str = Std.string(e());
    table.insert(_this.b, str);
    local _this = _this;
    _this.length = _this.length + #(str);
  elseif (tmp) == 2 then 
    local e1 = e[2];
    local eif = e[3];
    local eelse = e[4];
    local v = e1();
    if ((v == nil) or (v == false)) then 
      if (eelse ~= nil) then 
        self:run(eelse);
      end;
    else
      self:run(eif);
    end;
  elseif (tmp) == 3 then 
    local str = e[2];
    local _this = self.buf;
    local str = Std.string(str);
    table.insert(_this.b, str);
    local _this = _this;
    _this.length = _this.length + #(str);
  elseif (tmp) == 4 then 
    local l = e[2];
    local _g_head = l.h;
    while (_g_head ~= nil) do _hx_do_first_1 = false;
      
      local val = _g_head.item;
      _g_head = _g_head.next;
      local e = val;
      self:run(e);
    end;
  elseif (tmp) == 5 then 
    local e1 = e[2];
    local loop = e[3];
    local v = e1();
    local _hx_status, _hx_result = pcall(function() 
    
        local x = v:iterator();
        if (x.hasNext == nil) then 
          error(__haxe_Exception.thrown(nil),0);
        end;
        v = x;
      return _hx_pcall_default
    end)
    if not _hx_status and _hx_result == "_hx_pcall_break" then
    elseif not _hx_status then 
      local _g = _hx_result;
      local _hx_status, _hx_result = pcall(function() 
      
          if (v.hasNext == nil) then 
            error(__haxe_Exception.thrown(nil),0);
          end;
        return _hx_pcall_default
      end)
      if not _hx_status and _hx_result == "_hx_pcall_break" then
      elseif not _hx_status then 
        local _g = _hx_result;
        error(__haxe_Exception.thrown(Std.string("Cannot iter on ") .. Std.string(Std.string(v))),0);
      elseif _hx_result ~= _hx_pcall_default then
        return _hx_result
      end;
    elseif _hx_result ~= _hx_pcall_default then
      return _hx_result
    end;
    self.stack:push(self.context);
    local v = v;
    local ctx = v;
    while (ctx:hasNext()) do _hx_do_first_1 = false;
      
      local ctx = ctx:next();
      self.context = ctx;
      self:run(loop);
    end;
    self.context = self.stack:pop();
  elseif (tmp) == 6 then 
    local m = e[2];
    local params = e[3];
    local v = Reflect.field(self.macros, m);
    local pl = Array.new();
    local old = self.buf;
    pl:push(_hx_bind(self,self.resolve));
    local _g_head = params.h;
    while (_g_head ~= nil) do _hx_do_first_1 = false;
      
      local val = _g_head.item;
      _g_head = _g_head.next;
      local p = val;
      if (p[1] == 0) then 
        local v = p[2];
        pl:push(self:resolve(v));
      else
        self.buf = StringBuf.new();
        self:run(p);
        pl:push(table.concat(self.buf.b));
      end;
    end;
    self.buf = old;
    local _hx_status, _hx_result = pcall(function() 
    
        local _this = self.buf;
        local str = Std.string(Reflect.callMethod(self.macros,v,pl));
        table.insert(_this.b, str);
        local _this = _this;
        _this.length = _this.length + #(str);
      return _hx_pcall_default
    end)
    if not _hx_status and _hx_result == "_hx_pcall_break" then
    elseif not _hx_status then 
      local _g = _hx_result;
      local e = __haxe_Exception.caught(_g):unwrap();
      local plstr;
      local _hx_status, _hx_result = pcall(function() 
      
          plstr = pl:join(",");
        return _hx_pcall_default
      end)
      if not _hx_status and _hx_result == "_hx_pcall_break" then
      elseif not _hx_status then 
        local _g = _hx_result;
        plstr = "???";
      elseif _hx_result ~= _hx_pcall_default then
        return _hx_result
      end;
      local msg = Std.string(Std.string(Std.string(Std.string(Std.string(Std.string("Macro call ") .. Std.string(m)) .. Std.string("(")) .. Std.string(plstr)) .. Std.string(") failed (")) .. Std.string(Std.string(e))) .. Std.string(")");
      error(__haxe_Exception.thrown(msg),0);
    elseif _hx_result ~= _hx_pcall_default then
      return _hx_result
    end; end;
end

__haxe_Template.prototype.__class__ =  __haxe_Template

__haxe_ValueException.new = function(value,previous,native) 
  local self = _hx_new(__haxe_ValueException.prototype)
  __haxe_ValueException.super(self,value,previous,native)
  return self
end
__haxe_ValueException.super = function(self,value,previous,native) 
  __haxe_Exception.super(self,(function() 
    local _hx_1
    if (value == nil) then 
    _hx_1 = "null"; else 
    _hx_1 = Std.string(value); end
    return _hx_1
  end )(),previous,native);
  self.value = value;
  self.__skipStack = self.__skipStack + 1;
end
_hxClasses["haxe.ValueException"] = __haxe_ValueException
__haxe_ValueException.__name__ = "haxe.ValueException"
__haxe_ValueException.prototype = _hx_e();
__haxe_ValueException.prototype.value= nil;
__haxe_ValueException.prototype.unwrap = function(self) 
  do return self.value end
end

__haxe_ValueException.prototype.__class__ =  __haxe_ValueException
__haxe_ValueException.__super__ = __haxe_Exception
setmetatable(__haxe_ValueException.prototype,{__index=__haxe_Exception.prototype})
setmetatable(__haxe_ValueException.prototype.__properties__,{__index=__haxe_Exception.prototype.__properties__})

__haxe_ds_BalancedTree.new = function() 
  local self = _hx_new(__haxe_ds_BalancedTree.prototype)
  __haxe_ds_BalancedTree.super(self)
  return self
end
__haxe_ds_BalancedTree.super = function(self) 
end
_hxClasses["haxe.ds.BalancedTree"] = __haxe_ds_BalancedTree
__haxe_ds_BalancedTree.__name__ = "haxe.ds.BalancedTree"
__haxe_ds_BalancedTree.__interfaces__ = {__haxe_IMap}
__haxe_ds_BalancedTree.iteratorLoop = function(node,acc) 
  if (node ~= nil) then 
    __haxe_ds_BalancedTree.iteratorLoop(node.left, acc);
    acc:push(node.value);
    __haxe_ds_BalancedTree.iteratorLoop(node.right, acc);
  end;
end
__haxe_ds_BalancedTree.prototype = _hx_e();
__haxe_ds_BalancedTree.prototype.root= nil;
__haxe_ds_BalancedTree.prototype.set = function(self,key,value) 
  self.root = self:setLoop(key, value, self.root);
end
__haxe_ds_BalancedTree.prototype.get = function(self,key) 
  local node = self.root;
  while (node ~= nil) do _hx_do_first_1 = false;
    
    local c = self:compare(key, node.key);
    if (c == 0) then 
      do return node.value end;
    end;
    if (c < 0) then 
      node = node.left;
    else
      node = node.right;
    end;
  end;
  do return nil end
end
__haxe_ds_BalancedTree.prototype.remove = function(self,key) 
  local _hx_status, _hx_result = pcall(function() 
  
      self.root = self:removeLoop(key, self.root);
      do return true end;
    return _hx_pcall_default
  end)
  if not _hx_status and _hx_result == "_hx_pcall_break" then
  elseif not _hx_status then 
    local _g = _hx_result;
    if (__lua_Boot.__instanceof(__haxe_Exception.caught(_g):unwrap(), String)) then 
      do return false end;
    else
      error(_g,0);
    end;
  elseif _hx_result ~= _hx_pcall_default then
    return _hx_result
  end;
end
__haxe_ds_BalancedTree.prototype.exists = function(self,key) 
  local node = self.root;
  while (node ~= nil) do _hx_do_first_1 = false;
    
    local c = self:compare(key, node.key);
    if (c == 0) then 
      do return true end;
    else
      if (c < 0) then 
        node = node.left;
      else
        node = node.right;
      end;
    end;
  end;
  do return false end
end
__haxe_ds_BalancedTree.prototype.iterator = function(self) 
  local ret = _hx_tab_array({}, 0);
  __haxe_ds_BalancedTree.iteratorLoop(self.root, ret);
  do return __haxe_iterators_ArrayIterator.new(ret) end
end
__haxe_ds_BalancedTree.prototype.keyValueIterator = function(self) 
  do return __haxe_iterators_MapKeyValueIterator.new(self) end
end
__haxe_ds_BalancedTree.prototype.keys = function(self) 
  local ret = _hx_tab_array({}, 0);
  self:keysLoop(self.root, ret);
  do return __haxe_iterators_ArrayIterator.new(ret) end
end
__haxe_ds_BalancedTree.prototype.copy = function(self) 
  local copied = __haxe_ds_BalancedTree.new();
  copied.root = self.root;
  do return copied end
end
__haxe_ds_BalancedTree.prototype.setLoop = function(self,k,v,node) 
  if (node == nil) then 
    do return __haxe_ds_TreeNode.new(nil, k, v, nil) end;
  end;
  local c = self:compare(k, node.key);
  if (c == 0) then 
    do return __haxe_ds_TreeNode.new(node.left, k, v, node.right, (function() 
      local _hx_1
      if (node == nil) then 
      _hx_1 = 0; else 
      _hx_1 = node._height; end
      return _hx_1
    end )()) end;
  else
    if (c < 0) then 
      local nl = self:setLoop(k, v, node.left);
      do return self:balance(nl, node.key, node.value, node.right) end;
    else
      local nr = self:setLoop(k, v, node.right);
      do return self:balance(node.left, node.key, node.value, nr) end;
    end;
  end;
end
__haxe_ds_BalancedTree.prototype.removeLoop = function(self,k,node) 
  if (node == nil) then 
    error(__haxe_Exception.thrown("Not_found"),0);
  end;
  local c = self:compare(k, node.key);
  if (c == 0) then 
    do return self:merge(node.left, node.right) end;
  else
    if (c < 0) then 
      do return self:balance(self:removeLoop(k, node.left), node.key, node.value, node.right) end;
    else
      do return self:balance(node.left, node.key, node.value, self:removeLoop(k, node.right)) end;
    end;
  end;
end
__haxe_ds_BalancedTree.prototype.keysLoop = function(self,node,acc) 
  if (node ~= nil) then 
    self:keysLoop(node.left, acc);
    acc:push(node.key);
    self:keysLoop(node.right, acc);
  end;
end
__haxe_ds_BalancedTree.prototype.merge = function(self,t1,t2) 
  if (t1 == nil) then 
    do return t2 end;
  end;
  if (t2 == nil) then 
    do return t1 end;
  end;
  local t = self:minBinding(t2);
  do return self:balance(t1, t.key, t.value, self:removeMinBinding(t2)) end
end
__haxe_ds_BalancedTree.prototype.minBinding = function(self,t) 
  if (t == nil) then 
    error(__haxe_Exception.thrown("Not_found"),0);
  else
    if (t.left == nil) then 
      do return t end;
    else
      do return self:minBinding(t.left) end;
    end;
  end;
end
__haxe_ds_BalancedTree.prototype.removeMinBinding = function(self,t) 
  if (t.left == nil) then 
    do return t.right end;
  else
    do return self:balance(self:removeMinBinding(t.left), t.key, t.value, t.right) end;
  end;
end
__haxe_ds_BalancedTree.prototype.balance = function(self,l,k,v,r) 
  local hl = (function() 
    local _hx_1
    if (l == nil) then 
    _hx_1 = 0; else 
    _hx_1 = l._height; end
    return _hx_1
  end )();
  local hr = (function() 
    local _hx_2
    if (r == nil) then 
    _hx_2 = 0; else 
    _hx_2 = r._height; end
    return _hx_2
  end )();
  if (hl > (hr + 2)) then 
    local _this = l.left;
    local _this1 = l.right;
    if ((function() 
      local _hx_3
      if (_this == nil) then 
      _hx_3 = 0; else 
      _hx_3 = _this._height; end
      return _hx_3
    end )() >= (function() 
      local _hx_4
      if (_this1 == nil) then 
      _hx_4 = 0; else 
      _hx_4 = _this1._height; end
      return _hx_4
    end )()) then 
      do return __haxe_ds_TreeNode.new(l.left, l.key, l.value, __haxe_ds_TreeNode.new(l.right, k, v, r)) end;
    else
      do return __haxe_ds_TreeNode.new(__haxe_ds_TreeNode.new(l.left, l.key, l.value, l.right.left), l.right.key, l.right.value, __haxe_ds_TreeNode.new(l.right.right, k, v, r)) end;
    end;
  else
    if (hr > (hl + 2)) then 
      local _this = r.right;
      local _this1 = r.left;
      if ((function() 
        local _hx_5
        if (_this == nil) then 
        _hx_5 = 0; else 
        _hx_5 = _this._height; end
        return _hx_5
      end )() > (function() 
        local _hx_6
        if (_this1 == nil) then 
        _hx_6 = 0; else 
        _hx_6 = _this1._height; end
        return _hx_6
      end )()) then 
        do return __haxe_ds_TreeNode.new(__haxe_ds_TreeNode.new(l, k, v, r.left), r.key, r.value, r.right) end;
      else
        do return __haxe_ds_TreeNode.new(__haxe_ds_TreeNode.new(l, k, v, r.left.left), r.left.key, r.left.value, __haxe_ds_TreeNode.new(r.left.right, r.key, r.value, r.right)) end;
      end;
    else
      do return __haxe_ds_TreeNode.new(l, k, v, r, (function() 
        local _hx_7
        if (hl > hr) then 
        _hx_7 = hl; else 
        _hx_7 = hr; end
        return _hx_7
      end )() + 1) end;
    end;
  end;
end
__haxe_ds_BalancedTree.prototype.compare = function(self,k1,k2) 
  do return Reflect.compare(k1, k2) end
end
__haxe_ds_BalancedTree.prototype.toString = function(self) 
  if (self.root == nil) then 
    do return "[]" end;
  else
    do return Std.string(Std.string("[") .. Std.string(self.root:toString())) .. Std.string("]") end;
  end;
end
__haxe_ds_BalancedTree.prototype.clear = function(self) 
  self.root = nil;
end

__haxe_ds_BalancedTree.prototype.__class__ =  __haxe_ds_BalancedTree

__haxe_ds_TreeNode.new = function(l,k,v,r,h) 
  local self = _hx_new(__haxe_ds_TreeNode.prototype)
  __haxe_ds_TreeNode.super(self,l,k,v,r,h)
  return self
end
__haxe_ds_TreeNode.super = function(self,l,k,v,r,h) 
  if (h == nil) then 
    h = -1;
  end;
  self.left = l;
  self.key = k;
  self.value = v;
  self.right = r;
  if (h == -1) then 
    local tmp;
    local _this = self.left;
    local _this1 = self.right;
    if ((function() 
      local _hx_1
      if (_this == nil) then 
      _hx_1 = 0; else 
      _hx_1 = _this._height; end
      return _hx_1
    end )() > (function() 
      local _hx_2
      if (_this1 == nil) then 
      _hx_2 = 0; else 
      _hx_2 = _this1._height; end
      return _hx_2
    end )()) then 
      local _this = self.left;
      tmp = (function() 
        local _hx_3
        if (_this == nil) then 
        _hx_3 = 0; else 
        _hx_3 = _this._height; end
        return _hx_3
      end )();
    else
      local _this = self.right;
      tmp = (function() 
        local _hx_4
        if (_this == nil) then 
        _hx_4 = 0; else 
        _hx_4 = _this._height; end
        return _hx_4
      end )();
    end;
    self._height = tmp + 1;
  else
    self._height = h;
  end;
end
_hxClasses["haxe.ds.TreeNode"] = __haxe_ds_TreeNode
__haxe_ds_TreeNode.__name__ = "haxe.ds.TreeNode"
__haxe_ds_TreeNode.prototype = _hx_e();
__haxe_ds_TreeNode.prototype.left= nil;
__haxe_ds_TreeNode.prototype.right= nil;
__haxe_ds_TreeNode.prototype.key= nil;
__haxe_ds_TreeNode.prototype.value= nil;
__haxe_ds_TreeNode.prototype._height= nil;
__haxe_ds_TreeNode.prototype.toString = function(self) 
  do return Std.string(Std.string(((function() 
    local _hx_1
    if (self.left == nil) then 
    _hx_1 = ""; else 
    _hx_1 = Std.string(self.left:toString()) .. Std.string(", "); end
    return _hx_1
  end )())) .. Std.string((Std.string(Std.string(Std.string("") .. Std.string(Std.string(self.key))) .. Std.string(" => ")) .. Std.string(Std.string(self.value))))) .. Std.string(((function() 
    local _hx_2
    if (self.right == nil) then 
    _hx_2 = ""; else 
    _hx_2 = Std.string(", ") .. Std.string(self.right:toString()); end
    return _hx_2
  end )())) end
end

__haxe_ds_TreeNode.prototype.__class__ =  __haxe_ds_TreeNode

__haxe_ds_EnumValueMap.new = function() 
  local self = _hx_new(__haxe_ds_EnumValueMap.prototype)
  __haxe_ds_EnumValueMap.super(self)
  return self
end
__haxe_ds_EnumValueMap.super = function(self) 
  __haxe_ds_BalancedTree.super(self);
end
_hxClasses["haxe.ds.EnumValueMap"] = __haxe_ds_EnumValueMap
__haxe_ds_EnumValueMap.__name__ = "haxe.ds.EnumValueMap"
__haxe_ds_EnumValueMap.__interfaces__ = {__haxe_IMap}
__haxe_ds_EnumValueMap.prototype = _hx_e();
__haxe_ds_EnumValueMap.prototype.compare = function(self,k1,k2) 
  local d = k1[1] - k2[1];
  if (d ~= 0) then 
    do return d end;
  end;
  local p1 = k1:slice(2);
  local p2 = k2:slice(2);
  if ((p1.length == 0) and (p2.length == 0)) then 
    do return 0 end;
  end;
  do return self:compareArgs(p1, p2) end
end
__haxe_ds_EnumValueMap.prototype.compareArgs = function(self,a1,a2) 
  local ld = a1.length - a2.length;
  if (ld ~= 0) then 
    do return ld end;
  end;
  local _g = 0;
  local _g1 = a1.length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    local d = self:compareArg(a1[i], a2[i]);
    if (d ~= 0) then 
      do return d end;
    end;
  end;
  do return 0 end
end
__haxe_ds_EnumValueMap.prototype.compareArg = function(self,v1,v2) 
  if (Reflect.isEnumValue(v1) and Reflect.isEnumValue(v2)) then 
    do return self:compare(v1, v2) end;
  else
    if (__lua_Boot.__instanceof(v1, Array) and __lua_Boot.__instanceof(v2, Array)) then 
      do return self:compareArgs(v1, v2) end;
    else
      do return Reflect.compare(v1, v2) end;
    end;
  end;
end
__haxe_ds_EnumValueMap.prototype.copy = function(self) 
  local copied = __haxe_ds_EnumValueMap.new();
  copied.root = self.root;
  do return copied end
end

__haxe_ds_EnumValueMap.prototype.__class__ =  __haxe_ds_EnumValueMap
__haxe_ds_EnumValueMap.__super__ = __haxe_ds_BalancedTree
setmetatable(__haxe_ds_EnumValueMap.prototype,{__index=__haxe_ds_BalancedTree.prototype})

__haxe_ds_IntMap.new = function() 
  local self = _hx_new(__haxe_ds_IntMap.prototype)
  __haxe_ds_IntMap.super(self)
  return self
end
__haxe_ds_IntMap.super = function(self) 
  self.h = {};
end
_hxClasses["haxe.ds.IntMap"] = __haxe_ds_IntMap
__haxe_ds_IntMap.__name__ = "haxe.ds.IntMap"
__haxe_ds_IntMap.__interfaces__ = {__haxe_IMap}
__haxe_ds_IntMap.prototype = _hx_e();
__haxe_ds_IntMap.prototype.h= nil;
__haxe_ds_IntMap.prototype.set = function(self,key,value) 
  if (value == nil) then 
    self.h[key] = __haxe_ds_IntMap.tnull;
  else
    self.h[key] = value;
  end;
end
__haxe_ds_IntMap.prototype.get = function(self,key) 
  local ret = self.h[key];
  if (ret == __haxe_ds_IntMap.tnull) then 
    ret = nil;
  end;
  do return ret end
end
__haxe_ds_IntMap.prototype.exists = function(self,key) 
  do return self.h[key] ~= nil end
end
__haxe_ds_IntMap.prototype.remove = function(self,key) 
  if (self.h[key] == nil) then 
    do return false end;
  else
    self.h[key] = nil;
    do return true end;
  end;
end
__haxe_ds_IntMap.prototype.keys = function(self) 
  local _gthis = self;
  local cur = __lua__Lua_Lua_Fields_.next(self.h, nil);
  do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
    local ret = cur;
    cur = __lua__Lua_Lua_Fields_.next(_gthis.h, cur);
    do return ret end;
  end,hasNext=function(self) 
    do return cur ~= nil end;
  end}) end
end
__haxe_ds_IntMap.prototype.iterator = function(self) 
  local _gthis = self;
  local it = self:keys();
  do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self) 
    do return it:hasNext() end;
  end,next=function(self) 
    do return _gthis.h[it:next()] end;
  end}) end
end
__haxe_ds_IntMap.prototype.keyValueIterator = function(self) 
  do return __haxe_iterators_MapKeyValueIterator.new(self) end
end
__haxe_ds_IntMap.prototype.copy = function(self) 
  local copied = __haxe_ds_IntMap.new();
  local key = self:keys();
  while (key:hasNext()) do _hx_do_first_1 = false;
    
    local key = key:next();
    local ret = self.h[key];
    if (ret == __haxe_ds_IntMap.tnull) then 
      ret = nil;
    end;
    local value = ret;
    if (value == nil) then 
      copied.h[key] = __haxe_ds_IntMap.tnull;
    else
      copied.h[key] = value;
    end;
  end;
  do return copied end
end
__haxe_ds_IntMap.prototype.toString = function(self) 
  local s_b = {};
  local s_length = 0;
  local str = "[";
  table.insert(s_b, str);
  s_length = s_length + #(str);
  local it = self:keys();
  local i = it;
  while (i:hasNext()) do _hx_do_first_1 = false;
    
    local i = i:next();
    local str = Std.string(i);
    table.insert(s_b, str);
    s_length = s_length + #(str);
    local str = " => ";
    table.insert(s_b, str);
    s_length = s_length + #(str);
    local ret = self.h[i];
    if (ret == __haxe_ds_IntMap.tnull) then 
      ret = nil;
    end;
    local str = Std.string(ret);
    table.insert(s_b, str);
    s_length = s_length + #(str);
    if (it:hasNext()) then 
      local str = ", ";
      table.insert(s_b, str);
      s_length = s_length + #(str);
    end;
  end;
  local str = "]";
  table.insert(s_b, str);
  s_length = s_length + #(str);
  do return table.concat(s_b) end
end
__haxe_ds_IntMap.prototype.clear = function(self) 
  self.h = {};
end

__haxe_ds_IntMap.prototype.__class__ =  __haxe_ds_IntMap

__haxe_ds_List.new = function() 
  local self = _hx_new(__haxe_ds_List.prototype)
  __haxe_ds_List.super(self)
  return self
end
__haxe_ds_List.super = function(self) 
  self.length = 0;
end
_hxClasses["haxe.ds.List"] = __haxe_ds_List
__haxe_ds_List.__name__ = "haxe.ds.List"
__haxe_ds_List.prototype = _hx_e();
__haxe_ds_List.prototype.h= nil;
__haxe_ds_List.prototype.q= nil;
__haxe_ds_List.prototype.length= nil;
__haxe_ds_List.prototype.add = function(self,item) 
  local next = nil;
  local x = __haxe_ds__List_ListNode.new(item, next);
  if (self.h == nil) then 
    self.h = x;
  else
    self.q.next = x;
  end;
  self.q = x;
  self.length = self.length + 1;
end
__haxe_ds_List.prototype.push = function(self,item) 
  local x = __haxe_ds__List_ListNode.new(item, self.h);
  self.h = x;
  if (self.q == nil) then 
    self.q = x;
  end;
  self.length = self.length + 1;
end
__haxe_ds_List.prototype.first = function(self) 
  if (self.h == nil) then 
    do return nil end;
  else
    do return self.h.item end;
  end;
end
__haxe_ds_List.prototype.last = function(self) 
  if (self.q == nil) then 
    do return nil end;
  else
    do return self.q.item end;
  end;
end
__haxe_ds_List.prototype.pop = function(self) 
  if (self.h == nil) then 
    do return nil end;
  end;
  local x = self.h.item;
  self.h = self.h.next;
  if (self.h == nil) then 
    self.q = nil;
  end;
  self.length = self.length - 1;
  do return x end
end
__haxe_ds_List.prototype.isEmpty = function(self) 
  do return self.h == nil end
end
__haxe_ds_List.prototype.clear = function(self) 
  self.h = nil;
  self.q = nil;
  self.length = 0;
end
__haxe_ds_List.prototype.remove = function(self,v) 
  local prev = nil;
  local l = self.h;
  while (l ~= nil) do _hx_do_first_1 = false;
    
    if (l.item == v) then 
      if (prev == nil) then 
        self.h = l.next;
      else
        prev.next = l.next;
      end;
      if (self.q == l) then 
        self.q = prev;
      end;
      self.length = self.length - 1;
      do return true end;
    end;
    prev = l;
    l = l.next;
  end;
  do return false end
end
__haxe_ds_List.prototype.iterator = function(self) 
  do return __haxe_ds__List_ListIterator.new(self.h) end
end
__haxe_ds_List.prototype.keyValueIterator = function(self) 
  do return __haxe_ds__List_ListKeyValueIterator.new(self.h) end
end
__haxe_ds_List.prototype.toString = function(self) 
  local s_b = {};
  local s_length = 0;
  local first = true;
  local l = self.h;
  local str = "{";
  table.insert(s_b, str);
  s_length = s_length + #(str);
  while (l ~= nil) do _hx_do_first_1 = false;
    
    if (first) then 
      first = false;
    else
      local str = ", ";
      table.insert(s_b, str);
      s_length = s_length + #(str);
    end;
    local str = Std.string(l.item);
    table.insert(s_b, str);
    s_length = s_length + #(str);
    l = l.next;
  end;
  local str = "}";
  table.insert(s_b, str);
  s_length = s_length + #(str);
  do return table.concat(s_b) end
end
__haxe_ds_List.prototype.join = function(self,sep) 
  local s_b = {};
  local s_length = 0;
  local first = true;
  local l = self.h;
  while (l ~= nil) do _hx_do_first_1 = false;
    
    if (first) then 
      first = false;
    else
      local str = Std.string(sep);
      table.insert(s_b, str);
      s_length = s_length + #(str);
    end;
    local str = Std.string(l.item);
    table.insert(s_b, str);
    s_length = s_length + #(str);
    l = l.next;
  end;
  do return table.concat(s_b) end
end
__haxe_ds_List.prototype.filter = function(self,f) 
  local l2 = __haxe_ds_List.new();
  local l = self.h;
  while (l ~= nil) do _hx_do_first_1 = false;
    
    local v = l.item;
    l = l.next;
    if (f(v)) then 
      l2:add(v);
    end;
  end;
  do return l2 end
end
__haxe_ds_List.prototype.map = function(self,f) 
  local b = __haxe_ds_List.new();
  local l = self.h;
  while (l ~= nil) do _hx_do_first_1 = false;
    
    local v = l.item;
    l = l.next;
    b:add(f(v));
  end;
  do return b end
end

__haxe_ds_List.prototype.__class__ =  __haxe_ds_List

__haxe_ds__List_ListNode.new = function(item,next) 
  local self = _hx_new(__haxe_ds__List_ListNode.prototype)
  __haxe_ds__List_ListNode.super(self,item,next)
  return self
end
__haxe_ds__List_ListNode.super = function(self,item,next) 
  self.item = item;
  self.next = next;
end
_hxClasses["haxe.ds._List.ListNode"] = __haxe_ds__List_ListNode
__haxe_ds__List_ListNode.__name__ = "haxe.ds._List.ListNode"
__haxe_ds__List_ListNode.prototype = _hx_e();
__haxe_ds__List_ListNode.prototype.item= nil;
__haxe_ds__List_ListNode.prototype.next= nil;

__haxe_ds__List_ListNode.prototype.__class__ =  __haxe_ds__List_ListNode

__haxe_ds__List_ListIterator.new = function(head) 
  local self = _hx_new(__haxe_ds__List_ListIterator.prototype)
  __haxe_ds__List_ListIterator.super(self,head)
  return self
end
__haxe_ds__List_ListIterator.super = function(self,head) 
  self.head = head;
end
_hxClasses["haxe.ds._List.ListIterator"] = __haxe_ds__List_ListIterator
__haxe_ds__List_ListIterator.__name__ = "haxe.ds._List.ListIterator"
__haxe_ds__List_ListIterator.prototype = _hx_e();
__haxe_ds__List_ListIterator.prototype.head= nil;
__haxe_ds__List_ListIterator.prototype.hasNext = function(self) 
  do return self.head ~= nil end
end
__haxe_ds__List_ListIterator.prototype.next = function(self) 
  local val = self.head.item;
  self.head = self.head.next;
  do return val end
end

__haxe_ds__List_ListIterator.prototype.__class__ =  __haxe_ds__List_ListIterator

__haxe_ds__List_ListKeyValueIterator.new = function(head) 
  local self = _hx_new(__haxe_ds__List_ListKeyValueIterator.prototype)
  __haxe_ds__List_ListKeyValueIterator.super(self,head)
  return self
end
__haxe_ds__List_ListKeyValueIterator.super = function(self,head) 
  self.head = head;
  self.idx = 0;
end
_hxClasses["haxe.ds._List.ListKeyValueIterator"] = __haxe_ds__List_ListKeyValueIterator
__haxe_ds__List_ListKeyValueIterator.__name__ = "haxe.ds._List.ListKeyValueIterator"
__haxe_ds__List_ListKeyValueIterator.prototype = _hx_e();
__haxe_ds__List_ListKeyValueIterator.prototype.idx= nil;
__haxe_ds__List_ListKeyValueIterator.prototype.head= nil;
__haxe_ds__List_ListKeyValueIterator.prototype.hasNext = function(self) 
  do return self.head ~= nil end
end
__haxe_ds__List_ListKeyValueIterator.prototype.next = function(self) 
  local val = self.head.item;
  self.head = self.head.next;
  do return _hx_o({__fields__={value=true,key=true},value=val,key=(function() 
  local _hx_obj = self;
  local _hx_fld = 'idx';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)()}) end
end

__haxe_ds__List_ListKeyValueIterator.prototype.__class__ =  __haxe_ds__List_ListKeyValueIterator

__haxe_ds__Map_Map_Impl_.new = {}
_hxClasses["haxe.ds._Map.Map_Impl_"] = __haxe_ds__Map_Map_Impl_
__haxe_ds__Map_Map_Impl_.__name__ = "haxe.ds._Map.Map_Impl_"
__haxe_ds__Map_Map_Impl_.set = function(this1,key,value) 
  this1:set(key, value);
end
__haxe_ds__Map_Map_Impl_.get = function(this1,key) 
  do return this1:get(key) end;
end
__haxe_ds__Map_Map_Impl_.exists = function(this1,key) 
  do return this1:exists(key) end;
end
__haxe_ds__Map_Map_Impl_.remove = function(this1,key) 
  do return this1:remove(key) end;
end
__haxe_ds__Map_Map_Impl_.keys = function(this1) 
  do return this1:keys() end;
end
__haxe_ds__Map_Map_Impl_.iterator = function(this1) 
  do return this1:iterator() end;
end
__haxe_ds__Map_Map_Impl_.keyValueIterator = function(this1) 
  do return this1:keyValueIterator() end;
end
__haxe_ds__Map_Map_Impl_.copy = function(this1) 
  do return this1:copy() end;
end
__haxe_ds__Map_Map_Impl_.toString = function(this1) 
  do return this1:toString() end;
end
__haxe_ds__Map_Map_Impl_.clear = function(this1) 
  this1:clear();
end
__haxe_ds__Map_Map_Impl_.arrayWrite = function(this1,k,v) 
  this1:set(k, v);
  do return v end;
end
__haxe_ds__Map_Map_Impl_.toStringMap = function(t) 
  do return __haxe_ds_StringMap.new() end;
end
__haxe_ds__Map_Map_Impl_.toIntMap = function(t) 
  do return __haxe_ds_IntMap.new() end;
end
__haxe_ds__Map_Map_Impl_.toEnumValueMapMap = function(t) 
  do return __haxe_ds_EnumValueMap.new() end;
end
__haxe_ds__Map_Map_Impl_.toObjectMap = function(t) 
  do return __haxe_ds_ObjectMap.new() end;
end
__haxe_ds__Map_Map_Impl_.fromStringMap = function(map) 
  do return map end;
end
__haxe_ds__Map_Map_Impl_.fromIntMap = function(map) 
  do return map end;
end
__haxe_ds__Map_Map_Impl_.fromObjectMap = function(map) 
  do return map end;
end

__haxe_ds_ObjectMap.new = function() 
  local self = _hx_new(__haxe_ds_ObjectMap.prototype)
  __haxe_ds_ObjectMap.super(self)
  return self
end
__haxe_ds_ObjectMap.super = function(self) 
  self.h = {};
  self.k = {};
end
_hxClasses["haxe.ds.ObjectMap"] = __haxe_ds_ObjectMap
__haxe_ds_ObjectMap.__name__ = "haxe.ds.ObjectMap"
__haxe_ds_ObjectMap.__interfaces__ = {__haxe_IMap}
__haxe_ds_ObjectMap.assignId = function(obj) 
  obj.__id__ = (function() 
  local _hx_obj = __haxe_ds_ObjectMap;
  local _hx_fld = 'count';
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _hx_obj[_hx_fld];
   end)() do return obj.__id__ end;
end
__haxe_ds_ObjectMap.getId = function(obj) 
  do return obj.__id__ end;
end
__haxe_ds_ObjectMap.prototype = _hx_e();
__haxe_ds_ObjectMap.prototype.h= nil;
__haxe_ds_ObjectMap.prototype.k= nil;
__haxe_ds_ObjectMap.prototype.set = function(self,key,value) 
  self.h[key] = value;
  self.k[key] = true;
end
__haxe_ds_ObjectMap.prototype.get = function(self,key) 
  do return self.h[key] end
end
__haxe_ds_ObjectMap.prototype.exists = function(self,key) 
  do return self.k[key] ~= nil end
end
__haxe_ds_ObjectMap.prototype.remove = function(self,key) 
  if (self.k[key] == nil) then 
    do return false end;
  end;
  self.k[key] = nil;
  self.h[key] = nil;
  do return true end
end
__haxe_ds_ObjectMap.prototype.keys = function(self) 
  local _gthis = self;
  local cur = next(self.h, nil);
  do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
    local ret = cur;
    cur = next(_gthis.k, cur);
    do return ret end;
  end,hasNext=function(self) 
    do return cur ~= nil end;
  end}) end
end
__haxe_ds_ObjectMap.prototype.iterator = function(self) 
  local _gthis = self;
  local itr = self:keys();
  do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function(_,...) return _hx_bind(itr,itr.hasNext)(...) end,next=function(self) 
    do return _gthis.h[itr:next()] end;
  end}) end
end
__haxe_ds_ObjectMap.prototype.keyValueIterator = function(self) 
  do return __haxe_iterators_MapKeyValueIterator.new(self) end
end
__haxe_ds_ObjectMap.prototype.copy = function(self) 
  local copied = __haxe_ds_ObjectMap.new();
  local key = self:keys();
  while (key:hasNext()) do _hx_do_first_1 = false;
    
    local key = key:next();
    copied.h[key] = self.h[key];
    copied.k[key] = true;
  end;
  do return copied end
end
__haxe_ds_ObjectMap.prototype.toString = function(self) 
  local s_b = {};
  local s_length = 0;
  local str = "[";
  table.insert(s_b, str);
  s_length = s_length + #(str);
  local it = self:keys();
  local i = it;
  while (i:hasNext()) do _hx_do_first_1 = false;
    
    local i = i:next();
    local str = Std.string(i);
    table.insert(s_b, str);
    s_length = s_length + #(str);
    local str = " => ";
    table.insert(s_b, str);
    s_length = s_length + #(str);
    local str = Std.string(self.h[i]);
    table.insert(s_b, str);
    s_length = s_length + #(str);
    if (it:hasNext()) then 
      local str = ", ";
      table.insert(s_b, str);
      s_length = s_length + #(str);
    end;
  end;
  local str = "]";
  table.insert(s_b, str);
  s_length = s_length + #(str);
  do return table.concat(s_b) end
end
__haxe_ds_ObjectMap.prototype.clear = function(self) 
  self.h = {};
  self.k = {};
end

__haxe_ds_ObjectMap.prototype.__class__ =  __haxe_ds_ObjectMap

__haxe_ds__ReadOnlyArray_ReadOnlyArray_Impl_.new = {}
_hxClasses["haxe.ds._ReadOnlyArray.ReadOnlyArray_Impl_"] = __haxe_ds__ReadOnlyArray_ReadOnlyArray_Impl_
__haxe_ds__ReadOnlyArray_ReadOnlyArray_Impl_.__name__ = "haxe.ds._ReadOnlyArray.ReadOnlyArray_Impl_"
__haxe_ds__ReadOnlyArray_ReadOnlyArray_Impl_.__properties__ = {get_length="get_length"}
__haxe_ds__ReadOnlyArray_ReadOnlyArray_Impl_.get_length = function(this1) 
  do return this1.length end;
end
__haxe_ds__ReadOnlyArray_ReadOnlyArray_Impl_.get = function(this1,i) 
  do return this1[i] end;
end
__haxe_ds__ReadOnlyArray_ReadOnlyArray_Impl_.concat = function(this1,a) 
  do return this1:concat(a) end;
end

__haxe_ds_StringMap.new = function() 
  local self = _hx_new(__haxe_ds_StringMap.prototype)
  __haxe_ds_StringMap.super(self)
  return self
end
__haxe_ds_StringMap.super = function(self) 
  self.h = {};
end
_hxClasses["haxe.ds.StringMap"] = __haxe_ds_StringMap
__haxe_ds_StringMap.__name__ = "haxe.ds.StringMap"
__haxe_ds_StringMap.__interfaces__ = {__haxe_IMap}
__haxe_ds_StringMap.prototype = _hx_e();
__haxe_ds_StringMap.prototype.h= nil;
__haxe_ds_StringMap.prototype.set = function(self,key,value) 
  if (value == nil) then 
    self.h[key] = __haxe_ds_StringMap.tnull;
  else
    self.h[key] = value;
  end;
end
__haxe_ds_StringMap.prototype.get = function(self,key) 
  local ret = self.h[key];
  if (ret == __haxe_ds_StringMap.tnull) then 
    do return nil end;
  end;
  do return ret end
end
__haxe_ds_StringMap.prototype.exists = function(self,key) 
  do return self.h[key] ~= nil end
end
__haxe_ds_StringMap.prototype.remove = function(self,key) 
  if (self.h[key] == nil) then 
    do return false end;
  else
    self.h[key] = nil;
    do return true end;
  end;
end
__haxe_ds_StringMap.prototype.keys = function(self) 
  local _gthis = self;
  local cur = __lua__Lua_Lua_Fields_.next(self.h, nil);
  do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
    local ret = cur;
    cur = __lua__Lua_Lua_Fields_.next(_gthis.h, cur);
    do return ret end;
  end,hasNext=function(self) 
    do return cur ~= nil end;
  end}) end
end
__haxe_ds_StringMap.prototype.iterator = function(self) 
  local _gthis = self;
  local it = self:keys();
  do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self) 
    do return it:hasNext() end;
  end,next=function(self) 
    do return _gthis.h[it:next()] end;
  end}) end
end
__haxe_ds_StringMap.prototype.keyValueIterator = function(self) 
  do return __haxe_iterators_MapKeyValueIterator.new(self) end
end
__haxe_ds_StringMap.prototype.copy = function(self) 
  local copied = __haxe_ds_StringMap.new();
  local key = self:keys();
  while (key:hasNext()) do _hx_do_first_1 = false;
    
    local key = key:next();
    local ret = self.h[key];
    local value = (function() 
      local _hx_1
      if (ret == __haxe_ds_StringMap.tnull) then 
      _hx_1 = nil; else 
      _hx_1 = ret; end
      return _hx_1
    end )();
    if (value == nil) then 
      copied.h[key] = __haxe_ds_StringMap.tnull;
    else
      copied.h[key] = value;
    end;
  end;
  do return copied end
end
__haxe_ds_StringMap.prototype.toString = function(self) 
  local s_b = {};
  local s_length = 0;
  local str = "[";
  table.insert(s_b, str);
  s_length = s_length + #(str);
  local it = self:keys();
  local i = it;
  while (i:hasNext()) do _hx_do_first_1 = false;
    
    local i = i:next();
    local str = Std.string(i);
    table.insert(s_b, str);
    s_length = s_length + #(str);
    local str = " => ";
    table.insert(s_b, str);
    s_length = s_length + #(str);
    local ret = self.h[i];
    local str = Std.string((function() 
      local _hx_1
      if (ret == __haxe_ds_StringMap.tnull) then 
      _hx_1 = nil; else 
      _hx_1 = ret; end
      return _hx_1
    end )());
    table.insert(s_b, str);
    s_length = s_length + #(str);
    if (it:hasNext()) then 
      local str = ", ";
      table.insert(s_b, str);
      s_length = s_length + #(str);
    end;
  end;
  local str = "]";
  table.insert(s_b, str);
  s_length = s_length + #(str);
  do return table.concat(s_b) end
end
__haxe_ds_StringMap.prototype.clear = function(self) 
  self.h = {};
end

__haxe_ds_StringMap.prototype.__class__ =  __haxe_ds_StringMap

__haxe_format_JsonParser.new = function(str) 
  local self = _hx_new(__haxe_format_JsonParser.prototype)
  __haxe_format_JsonParser.super(self,str)
  return self
end
__haxe_format_JsonParser.super = function(self,str) 
  self.str = str;
  self.pos = 0;
end
_hxClasses["haxe.format.JsonParser"] = __haxe_format_JsonParser
__haxe_format_JsonParser.__name__ = "haxe.format.JsonParser"
__haxe_format_JsonParser.parse = function(str) 
  do return __haxe_format_JsonParser.new(str):doParse() end;
end
__haxe_format_JsonParser.prototype = _hx_e();
__haxe_format_JsonParser.prototype.str= nil;
__haxe_format_JsonParser.prototype.pos= nil;
__haxe_format_JsonParser.prototype.doParse = function(self) 
  local result = self:parseRec();
  local c;
  while (true) do _hx_do_first_1 = false;
    
    c = self:nextChar();
    if (not (c ~= nil)) then 
      break;
    end;
    local c = c;
    if (c) == 9 or (c) == 10 or (c) == 13 or (c) == 32 then else
    self:invalidChar(); end;
  end;
  do return result end
end
__haxe_format_JsonParser.prototype.parseRec = function(self) 
  while (true) do _hx_do_first_1 = false;
    
    local c = self:nextChar();
    local c1 = c;
    if (c1) == 9 or (c1) == 10 or (c1) == 13 or (c1) == 32 then 
    elseif (c1) == 34 then 
      do return self:parseString() end;
    elseif (c1) == 45 or (c1) == 48 or (c1) == 49 or (c1) == 50 or (c1) == 51 or (c1) == 52 or (c1) == 53 or (c1) == 54 or (c1) == 55 or (c1) == 56 or (c1) == 57 then 
      local c = c;
      local start = self.pos - 1;
      local minus = c == 45;
      local digit = not minus;
      local zero = c == 48;
      local point = false;
      local e = false;
      local pm = false;
      local _end = false;
      local _hx_do_first_2 = true;
      while (not _end) or _hx_do_first_2 do 
        _hx_do_first_2 = false;
        
        c = self:nextChar();
        local c = c;
        if (c) == 43 or (c) == 45 then 
          if (not e or pm) then 
            self:invalidNumber(start);
          end;
          digit = false;
          pm = true;
        elseif (c) == 46 then 
          if ((minus or point) or e) then 
            self:invalidNumber(start);
          end;
          digit = false;
          point = true;
        elseif (c) == 48 then 
          if (zero and not point) then 
            self:invalidNumber(start);
          end;
          if (minus) then 
            minus = false;
            zero = true;
          end;
          digit = true;
        elseif (c) == 49 or (c) == 50 or (c) == 51 or (c) == 52 or (c) == 53 or (c) == 54 or (c) == 55 or (c) == 56 or (c) == 57 then 
          if (zero and not point) then 
            self:invalidNumber(start);
          end;
          if (minus) then 
            minus = false;
          end;
          digit = true;
          zero = false;
        elseif (c) == 69 or (c) == 101 then 
          if ((minus or zero) or e) then 
            self:invalidNumber(start);
          end;
          digit = false;
          e = true;else
        if (not digit) then 
          self:invalidNumber(start);
        end;
        self.pos = self.pos - 1;
        _end = true; end;
      end;
      local f = Std.parseFloat(String.prototype.substr(self.str, start, self.pos - start));
      local i = Std.int(f);
      if (i == f) then 
        do return i end;
      else
        do return f end;
      end;
    elseif (c1) == 91 then 
      local arr = _hx_tab_array({}, 0);
      local comma = nil;
      while (true) do _hx_do_first_2 = false;
        
        local c = self:nextChar();
        local c = c;
        if (c) == 9 or (c) == 10 or (c) == 13 or (c) == 32 then 
        elseif (c) == 44 then 
          if (comma) then 
            comma = false;
          else
            self:invalidChar();
          end;
        elseif (c) == 93 then 
          if (comma == false) then 
            self:invalidChar();
          end;
          do return arr end;else
        if (comma) then 
          self:invalidChar();
        end;
        self.pos = self.pos - 1;
        arr:push(self:parseRec());
        comma = true; end;
      end;
    elseif (c1) == 102 then 
      local save = self.pos;
      if ((((self:nextChar() ~= 97) or (self:nextChar() ~= 108)) or (self:nextChar() ~= 115)) or (self:nextChar() ~= 101)) then 
        self.pos = save;
        self:invalidChar();
      end;
      do return false end;
    elseif (c1) == 110 then 
      local save = self.pos;
      if (((self:nextChar() ~= 117) or (self:nextChar() ~= 108)) or (self:nextChar() ~= 108)) then 
        self.pos = save;
        self:invalidChar();
      end;
      do return nil end;
    elseif (c1) == 116 then 
      local save = self.pos;
      if (((self:nextChar() ~= 114) or (self:nextChar() ~= 117)) or (self:nextChar() ~= 101)) then 
        self.pos = save;
        self:invalidChar();
      end;
      do return true end;
    elseif (c1) == 123 then 
      local obj = _hx_e();
      local field = nil;
      local comma = nil;
      while (true) do _hx_do_first_2 = false;
        
        local c = self:nextChar();
        local c = c;
        if (c) == 9 or (c) == 10 or (c) == 13 or (c) == 32 then 
        elseif (c) == 34 then 
          if ((field ~= nil) or comma) then 
            self:invalidChar();
          end;
          field = self:parseString();
        elseif (c) == 44 then 
          if (comma) then 
            comma = false;
          else
            self:invalidChar();
          end;
        elseif (c) == 58 then 
          if (field == nil) then 
            self:invalidChar();
          end;
          obj[field] = self:parseRec();
          field = nil;
          comma = true;
        elseif (c) == 125 then 
          if ((field ~= nil) or (comma == false)) then 
            self:invalidChar();
          end;
          do return obj end;else
        self:invalidChar(); end;
      end;else
    self:invalidChar(); end;
  end;
end
__haxe_format_JsonParser.prototype.parseString = function(self) 
  local start = self.pos;
  local buf = nil;
  local prev = -1;
  while (true) do _hx_do_first_1 = false;
    
    local c = self:nextChar();
    if (c == 34) then 
      break;
    end;
    if (c == 92) then 
      if (buf == nil) then 
        buf = StringBuf.new();
      end;
      local s = self.str;
      local len = (self.pos - start) - 1;
      local part = (function() 
        local _hx_1
        if (len == nil) then 
        _hx_1 = String.prototype.substr(s, start); else 
        _hx_1 = String.prototype.substr(s, start, len); end
        return _hx_1
      end )();
      table.insert(buf.b, part);
      local buf1 = buf;
      buf1.length = buf1.length + #(part);
      c = self:nextChar();
      local c1 = c;
      if (c1) == 34 or (c1) == 47 or (c1) == 92 then 
        table.insert(buf.b, string.char(c));
        local buf = buf;
        buf.length = buf.length + 1;
      elseif (c1) == 98 then 
        table.insert(buf.b, string.char(8));
        local buf = buf;
        buf.length = buf.length + 1;
      elseif (c1) == 102 then 
        table.insert(buf.b, string.char(12));
        local buf = buf;
        buf.length = buf.length + 1;
      elseif (c1) == 110 then 
        table.insert(buf.b, string.char(10));
        local buf = buf;
        buf.length = buf.length + 1;
      elseif (c1) == 114 then 
        table.insert(buf.b, string.char(13));
        local buf = buf;
        buf.length = buf.length + 1;
      elseif (c1) == 116 then 
        table.insert(buf.b, string.char(9));
        local buf = buf;
        buf.length = buf.length + 1;
      elseif (c1) == 117 then 
        local uc = Std.parseInt(Std.string("0x") .. Std.string(String.prototype.substr(self.str, self.pos, 4)));
        local tmp = self;
        tmp.pos = tmp.pos + 4;
        if (prev ~= -1) then 
          if ((uc < 56320) or (uc > 57343)) then 
            table.insert(buf.b, string.char(65533));
            local buf = buf;
            buf.length = buf.length + 1;
            prev = -1;
          else
            table.insert(buf.b, string.char(((_hx_bit.lshift(prev - 55296,10)) + (uc - 56320)) + 65536));
            local buf = buf;
            buf.length = buf.length + 1;
            prev = -1;
          end;
        else
          if ((uc >= 55296) and (uc <= 56319)) then 
            prev = uc;
          else
            table.insert(buf.b, string.char(uc));
            local buf = buf;
            buf.length = buf.length + 1;
          end;
        end;else
      error(__haxe_Exception.thrown(Std.string(Std.string(Std.string("Invalid escape sequence \\") .. Std.string(string.char(c))) .. Std.string(" at position ")) .. Std.string((self.pos - 1))),0); end;
      start = self.pos;
    else
      if (c >= 128) then 
        self.pos = self.pos + 1;
        if (c >= 252) then 
          local tmp = self;
          tmp.pos = tmp.pos + 4;
        else
          if (c >= 248) then 
            local tmp = self;
            tmp.pos = tmp.pos + 3;
          else
            if (c >= 240) then 
              local tmp = self;
              tmp.pos = tmp.pos + 2;
            else
              if (c >= 224) then 
                self.pos = self.pos + 1;
              end;
            end;
          end;
        end;
      else
        if (c == nil) then 
          error(__haxe_Exception.thrown("Unclosed string"),0);
        end;
      end;
    end;
  end;
  if (buf == nil) then 
    do return String.prototype.substr(self.str, start, (self.pos - start) - 1) end;
  else
    local s = self.str;
    local len = (self.pos - start) - 1;
    local part = (function() 
      local _hx_2
      if (len == nil) then 
      _hx_2 = String.prototype.substr(s, start); else 
      _hx_2 = String.prototype.substr(s, start, len); end
      return _hx_2
    end )();
    table.insert(buf.b, part);
    local buf1 = buf;
    buf1.length = buf1.length + #(part);
    do return table.concat(buf.b) end;
  end;
end
__haxe_format_JsonParser.prototype.parseNumber = function(self,c) 
  local start = self.pos - 1;
  local minus = c == 45;
  local digit = not minus;
  local zero = c == 48;
  local point = false;
  local e = false;
  local pm = false;
  local _end = false;
  local _hx_do_first_1 = true;
  while (not _end) or _hx_do_first_1 do 
    _hx_do_first_1 = false;
    
    c = self:nextChar();
    local c = c;
    if (c) == 43 or (c) == 45 then 
      if (not e or pm) then 
        self:invalidNumber(start);
      end;
      digit = false;
      pm = true;
    elseif (c) == 46 then 
      if ((minus or point) or e) then 
        self:invalidNumber(start);
      end;
      digit = false;
      point = true;
    elseif (c) == 48 then 
      if (zero and not point) then 
        self:invalidNumber(start);
      end;
      if (minus) then 
        minus = false;
        zero = true;
      end;
      digit = true;
    elseif (c) == 49 or (c) == 50 or (c) == 51 or (c) == 52 or (c) == 53 or (c) == 54 or (c) == 55 or (c) == 56 or (c) == 57 then 
      if (zero and not point) then 
        self:invalidNumber(start);
      end;
      if (minus) then 
        minus = false;
      end;
      digit = true;
      zero = false;
    elseif (c) == 69 or (c) == 101 then 
      if ((minus or zero) or e) then 
        self:invalidNumber(start);
      end;
      digit = false;
      e = true;else
    if (not digit) then 
      self:invalidNumber(start);
    end;
    self.pos = self.pos - 1;
    _end = true; end;
  end;
  local f = Std.parseFloat(String.prototype.substr(self.str, start, self.pos - start));
  local i = Std.int(f);
  if (i == f) then 
    do return i end;
  else
    do return f end;
  end;
end
__haxe_format_JsonParser.prototype.nextChar = function(self) 
  self.pos = self.pos + 1;
  do return string.byte(self.str, self.pos) end
end
__haxe_format_JsonParser.prototype.invalidChar = function(self) 
  self.pos = self.pos - 1;
  error(__haxe_Exception.thrown(Std.string(Std.string(Std.string("Invalid char ") .. Std.string(string.byte(self.str, self.pos))) .. Std.string(" at position ")) .. Std.string(self.pos)),0);
end
__haxe_format_JsonParser.prototype.invalidNumber = function(self,start) 
  error(__haxe_Exception.thrown(Std.string(Std.string(Std.string("Invalid number at position ") .. Std.string(start)) .. Std.string(": ")) .. Std.string(String.prototype.substr(self.str, start, self.pos - start))),0);
end

__haxe_format_JsonParser.prototype.__class__ =  __haxe_format_JsonParser

__haxe_format_JsonPrinter.new = function(replacer,space) 
  local self = _hx_new(__haxe_format_JsonPrinter.prototype)
  __haxe_format_JsonPrinter.super(self,replacer,space)
  return self
end
__haxe_format_JsonPrinter.super = function(self,replacer,space) 
  self.replacer = replacer;
  self.indent = space;
  self.pretty = space ~= nil;
  self.nind = 0;
  self.buf = StringBuf.new();
end
_hxClasses["haxe.format.JsonPrinter"] = __haxe_format_JsonPrinter
__haxe_format_JsonPrinter.__name__ = "haxe.format.JsonPrinter"
__haxe_format_JsonPrinter.print = function(o,replacer,space) 
  local printer = __haxe_format_JsonPrinter.new(replacer, space);
  printer:write("", o);
  do return table.concat(printer.buf.b) end;
end
__haxe_format_JsonPrinter.prototype = _hx_e();
__haxe_format_JsonPrinter.prototype.buf= nil;
__haxe_format_JsonPrinter.prototype.replacer= nil;
__haxe_format_JsonPrinter.prototype.indent= nil;
__haxe_format_JsonPrinter.prototype.pretty= nil;
__haxe_format_JsonPrinter.prototype.nind= nil;
__haxe_format_JsonPrinter.prototype.ipad = function(self) 
  if (self.pretty) then 
    local v = StringTools.lpad("", self.indent, self.nind * #(self.indent));
    local _this = self.buf;
    local str = Std.string(v);
    table.insert(_this.b, str);
    local _this = _this;
    _this.length = _this.length + #(str);
  end;
end
__haxe_format_JsonPrinter.prototype.newl = function(self) 
  if (self.pretty) then 
    local _this = self.buf;
    table.insert(_this.b, string.char(10));
    local _this = _this;
    _this.length = _this.length + 1;
  end;
end
__haxe_format_JsonPrinter.prototype.write = function(self,k,v) 
  if (self.replacer ~= nil) then 
    v = self.replacer(k, v);
  end;
  local _g = Type.typeof(v);
  local tmp = _g[1];
  if (tmp) == 0 then 
    local _this = self.buf;
    local str = "null";
    table.insert(_this.b, str);
    local _this = _this;
    _this.length = _this.length + #(str);
  elseif (tmp) == 1 then 
    local _this = self.buf;
    local str = Std.string(v);
    table.insert(_this.b, str);
    local _this = _this;
    _this.length = _this.length + #(str);
  elseif (tmp) == 2 then 
    local v = (function() 
      local _hx_1
      if (Math.isFinite(v)) then 
      _hx_1 = Std.string(v); else 
      _hx_1 = "null"; end
      return _hx_1
    end )();
    local _this = self.buf;
    local str = Std.string(v);
    table.insert(_this.b, str);
    local _this = _this;
    _this.length = _this.length + #(str);
  elseif (tmp) == 3 then 
    local _this = self.buf;
    local str = Std.string(v);
    table.insert(_this.b, str);
    local _this = _this;
    _this.length = _this.length + #(str);
  elseif (tmp) == 4 then 
    self:fieldsString(v, Reflect.fields(v));
  elseif (tmp) == 5 then 
    local _this = self.buf;
    local str = "\"<fun>\"";
    table.insert(_this.b, str);
    local _this = _this;
    _this.length = _this.length + #(str);
  elseif (tmp) == 6 then 
    local c = _g[2];
    if (c == String) then 
      self:quote(v);
    else
      if (c == Array) then 
        local v = v;
        local _this = self.buf;
        table.insert(_this.b, string.char(91));
        local _this = _this;
        _this.length = _this.length + 1;
        local len = v.length;
        local last = len - 1;
        local _g = 0;
        local _g1 = len;
        while (_g < _g1) do _hx_do_first_1 = false;
          
          _g = _g + 1;
          local i = _g - 1;
          if (i > 0) then 
            local _this = self.buf;
            table.insert(_this.b, string.char(44));
            local _this = _this;
            _this.length = _this.length + 1;
          else
            self.nind = self.nind + 1;
          end;
          if (self.pretty) then 
            local _this = self.buf;
            table.insert(_this.b, string.char(10));
            local _this = _this;
            _this.length = _this.length + 1;
          end;
          if (self.pretty) then 
            local v = StringTools.lpad("", self.indent, self.nind * #(self.indent));
            local _this = self.buf;
            local str = Std.string(v);
            table.insert(_this.b, str);
            local _this = _this;
            _this.length = _this.length + #(str);
          end;
          self:write(i, v[i]);
          if (i == last) then 
            self.nind = self.nind - 1;
            if (self.pretty) then 
              local _this = self.buf;
              table.insert(_this.b, string.char(10));
              local _this = _this;
              _this.length = _this.length + 1;
            end;
            if (self.pretty) then 
              local v = StringTools.lpad("", self.indent, self.nind * #(self.indent));
              local _this = self.buf;
              local str = Std.string(v);
              table.insert(_this.b, str);
              local _this = _this;
              _this.length = _this.length + #(str);
            end;
          end;
        end;
        local _this = self.buf;
        table.insert(_this.b, string.char(93));
        local _this = _this;
        _this.length = _this.length + 1;
      else
        if (c == __haxe_ds_StringMap) then 
          local v = v;
          local o = _hx_e();
          local k = v:keys();
          while (k:hasNext()) do _hx_do_first_1 = false;
            
            local k = k:next();
            local ret = v.h[k];
            o[k] = (function() 
              local _hx_2
              if (ret == __haxe_ds_StringMap.tnull) then 
              _hx_2 = nil; else 
              _hx_2 = ret; end
              return _hx_2
            end )();
          end;
          local v = o;
          self:fieldsString(v, Reflect.fields(v));
        else
          if (c == Date) then 
            local v = v;
            self:quote(__lua_Boot.dateStr(v));
          else
            self:classString(v);
          end;
        end;
      end;
    end;
  elseif (tmp) == 7 then 
    local _g = _g[2];
    local i = v[1];
    local v = Std.string(i);
    local _this = self.buf;
    local str = Std.string(v);
    table.insert(_this.b, str);
    local _this = _this;
    _this.length = _this.length + #(str);
  elseif (tmp) == 8 then 
    local _this = self.buf;
    local str = "\"???\"";
    table.insert(_this.b, str);
    local _this = _this;
    _this.length = _this.length + #(str); end;
end
__haxe_format_JsonPrinter.prototype.classString = function(self,v) 
  self:fieldsString(v, Type.getInstanceFields(Type.getClass(v)));
end
__haxe_format_JsonPrinter.prototype.objString = function(self,v) 
  self:fieldsString(v, Reflect.fields(v));
end
__haxe_format_JsonPrinter.prototype.fieldsString = function(self,v,fields) 
  local _this = self.buf;
  table.insert(_this.b, string.char(123));
  local _this = _this;
  _this.length = _this.length + 1;
  local len = fields.length;
  local empty = true;
  local _g = 0;
  local _g1 = len;
  local _hx_continue_1 = false;
  while (_g < _g1) do _hx_do_first_1 = false;
    repeat 
    _g = _g + 1;
    local i = _g - 1;
    local f = fields[i];
    local value = Reflect.field(v, f);
    if (Reflect.isFunction(value)) then 
      break;
    end;
    if (empty) then 
      self.nind = self.nind + 1;
      empty = false;
    else
      local _this = self.buf;
      table.insert(_this.b, string.char(44));
      local _this = _this;
      _this.length = _this.length + 1;
    end;
    if (self.pretty) then 
      local _this = self.buf;
      table.insert(_this.b, string.char(10));
      local _this = _this;
      _this.length = _this.length + 1;
    end;
    if (self.pretty) then 
      local v = StringTools.lpad("", self.indent, self.nind * #(self.indent));
      local _this = self.buf;
      local str = Std.string(v);
      table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + #(str);
    end;
    self:quote(f);
    local _this = self.buf;
    table.insert(_this.b, string.char(58));
    local _this = _this;
    _this.length = _this.length + 1;
    if (self.pretty) then 
      local _this = self.buf;
      table.insert(_this.b, string.char(32));
      local _this = _this;
      _this.length = _this.length + 1;
    end;
    self:write(f, value);until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
  if (not empty) then 
    self.nind = self.nind - 1;
    if (self.pretty) then 
      local _this = self.buf;
      table.insert(_this.b, string.char(10));
      local _this = _this;
      _this.length = _this.length + 1;
    end;
    if (self.pretty) then 
      local v = StringTools.lpad("", self.indent, self.nind * #(self.indent));
      local _this = self.buf;
      local str = Std.string(v);
      table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + #(str);
    end;
  end;
  local _this = self.buf;
  table.insert(_this.b, string.char(125));
  local _this = _this;
  _this.length = _this.length + 1;
end
__haxe_format_JsonPrinter.prototype.quote = function(self,s) 
  local _this = self.buf;
  table.insert(_this.b, string.char(34));
  local _this = _this;
  _this.length = _this.length + 1;
  local i = 0;
  local length = #(s);
  while (i < length) do _hx_do_first_1 = false;
    
    i = i + 1;
    local c = string.byte(s, (i - 1) + 1);
    local c1 = c;
    if (c1) == 8 then 
      local _this = self.buf;
      local str = "\\b";
      table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + #(str);
    elseif (c1) == 9 then 
      local _this = self.buf;
      local str = "\\t";
      table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + #(str);
    elseif (c1) == 10 then 
      local _this = self.buf;
      local str = "\\n";
      table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + #(str);
    elseif (c1) == 12 then 
      local _this = self.buf;
      local str = "\\f";
      table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + #(str);
    elseif (c1) == 13 then 
      local _this = self.buf;
      local str = "\\r";
      table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + #(str);
    elseif (c1) == 34 then 
      local _this = self.buf;
      local str = "\\\"";
      table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + #(str);
    elseif (c1) == 92 then 
      local _this = self.buf;
      local str = "\\\\";
      table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + #(str);else
    local _this = self.buf;
    table.insert(_this.b, string.char(c));
    local _this = _this;
    _this.length = _this.length + 1; end;
  end;
  local _this = self.buf;
  table.insert(_this.b, string.char(34));
  local _this = _this;
  _this.length = _this.length + 1;
end

__haxe_format_JsonPrinter.prototype.__class__ =  __haxe_format_JsonPrinter

__haxe_iterators_ArrayKeyValueIterator.new = function(array) 
  local self = _hx_new(__haxe_iterators_ArrayKeyValueIterator.prototype)
  __haxe_iterators_ArrayKeyValueIterator.super(self,array)
  return self
end
__haxe_iterators_ArrayKeyValueIterator.super = function(self,array) 
  self.current = 0;
  self.array = array;
end
_hxClasses["haxe.iterators.ArrayKeyValueIterator"] = __haxe_iterators_ArrayKeyValueIterator
__haxe_iterators_ArrayKeyValueIterator.__name__ = "haxe.iterators.ArrayKeyValueIterator"
__haxe_iterators_ArrayKeyValueIterator.prototype = _hx_e();
__haxe_iterators_ArrayKeyValueIterator.prototype.current= nil;
__haxe_iterators_ArrayKeyValueIterator.prototype.array= nil;
__haxe_iterators_ArrayKeyValueIterator.prototype.hasNext = function(self) 
  do return self.current < self.array.length end
end
__haxe_iterators_ArrayKeyValueIterator.prototype.next = function(self) 
  do return _hx_o({__fields__={value=true,key=true},value=self.array[self.current],key=(function() 
  local _hx_obj = self;
  local _hx_fld = 'current';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)()}) end
end

__haxe_iterators_ArrayKeyValueIterator.prototype.__class__ =  __haxe_iterators_ArrayKeyValueIterator

__haxe_iterators_MapKeyValueIterator.new = function(map) 
  local self = _hx_new(__haxe_iterators_MapKeyValueIterator.prototype)
  __haxe_iterators_MapKeyValueIterator.super(self,map)
  return self
end
__haxe_iterators_MapKeyValueIterator.super = function(self,map) 
  self.map = map;
  self.keys = map:keys();
end
_hxClasses["haxe.iterators.MapKeyValueIterator"] = __haxe_iterators_MapKeyValueIterator
__haxe_iterators_MapKeyValueIterator.__name__ = "haxe.iterators.MapKeyValueIterator"
__haxe_iterators_MapKeyValueIterator.prototype = _hx_e();
__haxe_iterators_MapKeyValueIterator.prototype.map= nil;
__haxe_iterators_MapKeyValueIterator.prototype.keys= nil;
__haxe_iterators_MapKeyValueIterator.prototype.hasNext = function(self) 
  do return self.keys:hasNext() end
end
__haxe_iterators_MapKeyValueIterator.prototype.next = function(self) 
  local key = self.keys:next();
  do return _hx_o({__fields__={value=true,key=true},value=self.map:get(key),key=key}) end
end

__haxe_iterators_MapKeyValueIterator.prototype.__class__ =  __haxe_iterators_MapKeyValueIterator

__haxe_iterators_RestIterator.new = function(args) 
  local self = _hx_new(__haxe_iterators_RestIterator.prototype)
  __haxe_iterators_RestIterator.super(self,args)
  return self
end
__haxe_iterators_RestIterator.super = function(self,args) 
  self.current = 0;
  self.args = args;
end
_hxClasses["haxe.iterators.RestIterator"] = __haxe_iterators_RestIterator
__haxe_iterators_RestIterator.__name__ = "haxe.iterators.RestIterator"
__haxe_iterators_RestIterator.prototype = _hx_e();
__haxe_iterators_RestIterator.prototype.args= nil;
__haxe_iterators_RestIterator.prototype.current= nil;
__haxe_iterators_RestIterator.prototype.hasNext = function(self) 
  do return self.current < table.maxn(self.args) end
end
__haxe_iterators_RestIterator.prototype.next = function(self) 
  local index = (function() 
  local _hx_obj = self;
  local _hx_fld = 'current';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)();
  do return self.args[index + 1] end
end

__haxe_iterators_RestIterator.prototype.__class__ =  __haxe_iterators_RestIterator

__haxe_iterators_RestKeyValueIterator.new = function(args) 
  local self = _hx_new(__haxe_iterators_RestKeyValueIterator.prototype)
  __haxe_iterators_RestKeyValueIterator.super(self,args)
  return self
end
__haxe_iterators_RestKeyValueIterator.super = function(self,args) 
  self.current = 0;
  self.args = args;
end
_hxClasses["haxe.iterators.RestKeyValueIterator"] = __haxe_iterators_RestKeyValueIterator
__haxe_iterators_RestKeyValueIterator.__name__ = "haxe.iterators.RestKeyValueIterator"
__haxe_iterators_RestKeyValueIterator.prototype = _hx_e();
__haxe_iterators_RestKeyValueIterator.prototype.args= nil;
__haxe_iterators_RestKeyValueIterator.prototype.current= nil;
__haxe_iterators_RestKeyValueIterator.prototype.hasNext = function(self) 
  do return self.current < table.maxn(self.args) end
end
__haxe_iterators_RestKeyValueIterator.prototype.next = function(self) 
  local tmp = self.current;
  local index = (function() 
  local _hx_obj = self;
  local _hx_fld = 'current';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)();
  do return _hx_o({__fields__={key=true,value=true},key=tmp,value=self.args[index + 1]}) end
end

__haxe_iterators_RestKeyValueIterator.prototype.__class__ =  __haxe_iterators_RestKeyValueIterator

__haxe_iterators_StringIterator.new = function(s) 
  local self = _hx_new(__haxe_iterators_StringIterator.prototype)
  __haxe_iterators_StringIterator.super(self,s)
  return self
end
__haxe_iterators_StringIterator.super = function(self,s) 
  self.codes = utf8.codes(s);
  self.str = s;
  local _hx_1_cp_position, _hx_1_cp_codepoint = self.codes(self.str, 0);
  self.codepoint = _hx_1_cp_codepoint;
  self.position = _hx_1_cp_position;
end
_hxClasses["haxe.iterators.StringIterator"] = __haxe_iterators_StringIterator
__haxe_iterators_StringIterator.__name__ = "haxe.iterators.StringIterator"
__haxe_iterators_StringIterator.prototype = _hx_e();
__haxe_iterators_StringIterator.prototype.codes= nil;
__haxe_iterators_StringIterator.prototype.codepoint= nil;
__haxe_iterators_StringIterator.prototype.str= nil;
__haxe_iterators_StringIterator.prototype.position= nil;
__haxe_iterators_StringIterator.prototype.hasNext = function(self) 
  do return self.codepoint ~= nil end
end
__haxe_iterators_StringIterator.prototype.next = function(self) 
  local ret = self.codepoint;
  local _hx_1_cp_position, _hx_1_cp_codepoint = self.codes(self.str, self.position);
  self.codepoint = _hx_1_cp_codepoint;
  self.position = _hx_1_cp_position;
  do return ret end
end

__haxe_iterators_StringIterator.prototype.__class__ =  __haxe_iterators_StringIterator

__haxe_iterators_StringIteratorUnicode.new = function(s) 
  local self = _hx_new(__haxe_iterators_StringIteratorUnicode.prototype)
  __haxe_iterators_StringIteratorUnicode.super(self,s)
  return self
end
__haxe_iterators_StringIteratorUnicode.super = function(self,s) 
  self.offset = 0;
  self.s = s;
end
_hxClasses["haxe.iterators.StringIteratorUnicode"] = __haxe_iterators_StringIteratorUnicode
__haxe_iterators_StringIteratorUnicode.__name__ = "haxe.iterators.StringIteratorUnicode"
__haxe_iterators_StringIteratorUnicode.unicodeIterator = function(s) 
  do return __haxe_iterators_StringIteratorUnicode.new(s) end;
end
__haxe_iterators_StringIteratorUnicode.prototype = _hx_e();
__haxe_iterators_StringIteratorUnicode.prototype.offset= nil;
__haxe_iterators_StringIteratorUnicode.prototype.s= nil;
__haxe_iterators_StringIteratorUnicode.prototype.hasNext = function(self) 
  do return self.offset < #(self.s) end
end
__haxe_iterators_StringIteratorUnicode.prototype.next = function(self) 
  local index = (function() 
  local _hx_obj = self;
  local _hx_fld = 'offset';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)();
  do return string.byte(self.s, index + 1) end
end

__haxe_iterators_StringIteratorUnicode.prototype.__class__ =  __haxe_iterators_StringIteratorUnicode

__haxe_iterators_StringKeyValueIterator.new = function(s) 
  local self = _hx_new(__haxe_iterators_StringKeyValueIterator.prototype)
  __haxe_iterators_StringKeyValueIterator.super(self,s)
  return self
end
__haxe_iterators_StringKeyValueIterator.super = function(self,s) 
  self.offset = 0;
  self.s = s;
end
_hxClasses["haxe.iterators.StringKeyValueIterator"] = __haxe_iterators_StringKeyValueIterator
__haxe_iterators_StringKeyValueIterator.__name__ = "haxe.iterators.StringKeyValueIterator"
__haxe_iterators_StringKeyValueIterator.prototype = _hx_e();
__haxe_iterators_StringKeyValueIterator.prototype.offset= nil;
__haxe_iterators_StringKeyValueIterator.prototype.s= nil;
__haxe_iterators_StringKeyValueIterator.prototype.hasNext = function(self) 
  do return self.offset < #(self.s) end
end
__haxe_iterators_StringKeyValueIterator.prototype.next = function(self) 
  local tmp = self.offset;
  local index = (function() 
  local _hx_obj = self;
  local _hx_fld = 'offset';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)();
  do return _hx_o({__fields__={key=true,value=true},key=tmp,value=string.byte(self.s, index + 1)}) end
end

__haxe_iterators_StringKeyValueIterator.prototype.__class__ =  __haxe_iterators_StringKeyValueIterator

__lua_Boot.new = {}
_hxClasses["lua.Boot"] = __lua_Boot
__lua_Boot.__name__ = "lua.Boot"
__lua_Boot.__properties__ = {get_os_patterns="get_os_patterns"}
__lua_Boot._ = nil
__lua_Boot.__unhtml = function(s) 
  do return String.prototype.split(String.prototype.split(String.prototype.split(s, "&"):join("&amp;"), "<"):join("&lt;"), ">"):join("&gt;") end;
end
__lua_Boot.isClass = function(o) 
  if (__lua__Lua_Lua_Fields_.type(o) ~= "table") then 
    do return false end;
  else
    do return o.__name__ end;
  end;
end
__lua_Boot.isEnum = function(e) 
  if (__lua__Lua_Lua_Fields_.type(e) ~= "table") then 
    do return false end;
  else
    do return e.__ename__ end;
  end;
end
__lua_Boot.getClass = function(o) 
  if (__lua_Boot.__instanceof(o, Array)) then 
    do return Array end;
  else
    if (__lua_Boot.__instanceof(o, String)) then 
      do return String end;
    else
      local cl = o.__class__;
      if (cl ~= nil) then 
        do return cl end;
      else
        do return nil end;
      end;
    end;
  end;
end
__lua_Boot.__instanceof = function(o,cl) 
  if (cl == nil) then 
    do return false end;
  end;
  local cl1 = cl;
  if (cl1) == Array then 
    do return __lua_Boot.isArray(o) end;
  elseif (cl1) == Bool then 
    do return __lua__Lua_Lua_Fields_.type(o) == "boolean" end;
  elseif (cl1) == Dynamic then 
    do return o ~= nil end;
  elseif (cl1) == Float then 
    do return __lua__Lua_Lua_Fields_.type(o) == "number" end;
  elseif (cl1) == Int then 
    if (__lua__Lua_Lua_Fields_.type(o) == "number") then 
      do return _hx_bit_clamp(o) == o end;
    else
      do return false end;
    end;
  elseif (cl1) == String then 
    do return __lua__Lua_Lua_Fields_.type(o) == "string" end;
  elseif (cl1) == table then 
    do return __lua__Lua_Lua_Fields_.type(o) == "table" end;
  elseif (cl1) == __lua_Thread then 
    do return __lua__Lua_Lua_Fields_.type(o) == "thread" end;
  elseif (cl1) == __lua_UserData then 
    do return __lua__Lua_Lua_Fields_.type(o) == "userdata" end;else
  if (((o ~= nil) and (__lua__Lua_Lua_Fields_.type(o) == "table")) and (__lua__Lua_Lua_Fields_.type(cl) == "table")) then 
    local tmp;
    if (__lua_Boot.__instanceof(o, Array)) then 
      tmp = Array;
    else
      if (__lua_Boot.__instanceof(o, String)) then 
        tmp = String;
      else
        local cl = o.__class__;
        tmp = (function() 
          local _hx_1
          if (cl ~= nil) then 
          _hx_1 = cl; else 
          _hx_1 = nil; end
          return _hx_1
        end )();
      end;
    end;
    if (__lua_Boot.extendsOrImplements(tmp, cl)) then 
      do return true end;
    end;
    if ((function() 
      local _hx_2
      if (cl == Class) then 
      _hx_2 = o.__name__ ~= nil; else 
      _hx_2 = false; end
      return _hx_2
    end )()) then 
      do return true end;
    end;
    if ((function() 
      local _hx_3
      if (cl == Enum) then 
      _hx_3 = o.__ename__ ~= nil; else 
      _hx_3 = false; end
      return _hx_3
    end )()) then 
      do return true end;
    end;
    do return o.__enum__ == cl end;
  else
    do return false end;
  end; end;
end
__lua_Boot.isArray = function(o) 
  if (__lua__Lua_Lua_Fields_.type(o) == "table") then 
    if ((o.__enum__ == nil) and (__lua__Lua_Lua_Fields_.getmetatable(o) ~= nil)) then 
      do return __lua__Lua_Lua_Fields_.getmetatable(o).__index == Array.prototype end;
    else
      do return false end;
    end;
  else
    do return false end;
  end;
end
__lua_Boot.inheritsFrom = function(o,cl) 
  while ((__lua__Lua_Lua_Fields_.getmetatable(o) ~= nil) and (__lua__Lua_Lua_Fields_.getmetatable(o).__index ~= nil)) do _hx_do_first_1 = false;
    
    if (__lua__Lua_Lua_Fields_.getmetatable(o).__index == cl.prototype) then 
      do return true end;
    end;
    o = __lua__Lua_Lua_Fields_.getmetatable(o).__index;
  end;
  do return false end;
end
__lua_Boot.__cast = function(o,t) 
  if ((o == nil) or __lua_Boot.__instanceof(o, t)) then 
    do return o end;
  else
    error(__haxe_Exception.thrown(Std.string(Std.string(Std.string("Cannot cast ") .. Std.string(Std.string(o))) .. Std.string(" to ")) .. Std.string(Std.string(t))),0);
  end;
end
__lua_Boot.defArray = function(tab,length) 
  if (length == nil) then 
    length = table.maxn(tab);
    if (length > 0) then 
      local head = tab[1];
      table.remove(tab, 1);
      tab[0] = head;
      do return _hx_tab_array(tab, length) end;
    else
      do return _hx_tab_array({}, 0) end;
    end;
  else
    do return _hx_tab_array(tab, length) end;
  end;
end
__lua_Boot.tableToObject = function(t) 
  do return _hx_o(t) end;
end
__lua_Boot.dateStr = function(date) 
  local m = date:getMonth() + 1;
  local d = date:getDate();
  local h = date:getHours();
  local mi = date:getMinutes();
  local s = date:getSeconds();
  do return Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(date:getFullYear()) .. Std.string("-")) .. Std.string(((function() 
    local _hx_1
    if (m < 10) then 
    _hx_1 = Std.string("0") .. Std.string(m); else 
    _hx_1 = Std.string("") .. Std.string(m); end
    return _hx_1
  end )()))) .. Std.string("-")) .. Std.string(((function() 
    local _hx_2
    if (d < 10) then 
    _hx_2 = Std.string("0") .. Std.string(d); else 
    _hx_2 = Std.string("") .. Std.string(d); end
    return _hx_2
  end )()))) .. Std.string(" ")) .. Std.string(((function() 
    local _hx_3
    if (h < 10) then 
    _hx_3 = Std.string("0") .. Std.string(h); else 
    _hx_3 = Std.string("") .. Std.string(h); end
    return _hx_3
  end )()))) .. Std.string(":")) .. Std.string(((function() 
    local _hx_4
    if (mi < 10) then 
    _hx_4 = Std.string("0") .. Std.string(mi); else 
    _hx_4 = Std.string("") .. Std.string(mi); end
    return _hx_4
  end )()))) .. Std.string(":")) .. Std.string(((function() 
    local _hx_5
    if (s < 10) then 
    _hx_5 = Std.string("0") .. Std.string(s); else 
    _hx_5 = Std.string("") .. Std.string(s); end
    return _hx_5
  end )())) end;
end
__lua_Boot.clampInt32 = function(x) 
  do return _hx_bit_clamp(x) end;
end
__lua_Boot.strDate = function(s) 
  local _g = #(s);
  if (_g) == 8 then 
    local k = String.prototype.split(s, ":");
    local t = ((__lua__Lua_Lua_Fields_.tonumber(k[0]) * 3600000.) + (__lua__Lua_Lua_Fields_.tonumber(k[1]) * 60000.)) + (__lua__Lua_Lua_Fields_.tonumber(k[2]) * 1000.);
    local d = _hx_e();
    setmetatable(d, _hx_o({__fields__={__index=true},__index=Date.prototype}));
    d.t = t / 1000;
    d.d = os.date("*t", Std.int(d.t));
    d.dUTC = os.date("!*t", Std.int(d.t));
    do return d end;
  elseif (_g) == 10 then 
    local k = String.prototype.split(s, "-");
    do return Date.new(__lua__Lua_Lua_Fields_.tonumber(k[0]), __lua__Lua_Lua_Fields_.tonumber(k[1]) - 1, __lua__Lua_Lua_Fields_.tonumber(k[2]), 0, 0, 0) end;
  elseif (_g) == 19 then 
    local k = String.prototype.split(s, " ");
    local y = String.prototype.split(k[0], "-");
    local t = String.prototype.split(k[1], ":");
    do return Date.new(__lua__Lua_Lua_Fields_.tonumber(y[0]), __lua__Lua_Lua_Fields_.tonumber(y[1]) - 1, __lua__Lua_Lua_Fields_.tonumber(y[2]), __lua__Lua_Lua_Fields_.tonumber(t[0]), __lua__Lua_Lua_Fields_.tonumber(t[1]), __lua__Lua_Lua_Fields_.tonumber(t[2])) end;else
  error(__haxe_Exception.thrown(Std.string("Invalid date format : ") .. Std.string(s)),0); end;
end
__lua_Boot.extendsOrImplements = function(cl1,cl2) 
  if ((cl1 == nil) or (cl2 == nil)) then 
    do return false end;
  else
    if (cl1 == cl2) then 
      do return true end;
    else
      if (cl1.__interfaces__ ~= nil) then 
        local intf = cl1.__interfaces__;
        local _g = 1;
        local _g1 = table.maxn(intf) + 1;
        while (_g < _g1) do _hx_do_first_1 = false;
          
          _g = _g + 1;
          local i = _g - 1;
          if (__lua_Boot.extendsOrImplements(intf[i], cl2)) then 
            do return true end;
          end;
        end;
      end;
    end;
  end;
  do return __lua_Boot.extendsOrImplements(cl1.__super__, cl2) end;
end
__lua_Boot.shellEscapeCmd = function(cmd,args) 
  do return cmd end;
end
__lua_Boot.tempFile = function() 
  do return "" end;
end
__lua_Boot.get_os_patterns = function() 
  do return __lua_Boot.os_patterns end;
end
__lua_Boot.systemName = function() 
  do return nil end;
end

__lua_Lib.new = {}
_hxClasses["lua.Lib"] = __lua_Lib
__lua_Lib.__name__ = "lua.Lib"
__lua_Lib.println = function(v) 
  __lua_Lib.print(Std.string(Std.string(Std.string(v))));
end
__lua_Lib.print = function(v) 
  __lua_Lib.print(Std.string(v));
end
__lua_Lib.patternQuote = function(str) 
  do return string.gsub(str, "[%(%)%.%%%+%-%*%?%[%]%^%$]", function(c) 
    do return Std.string("%") .. Std.string(c) end;
  end) end;
end
__lua_Lib.fillArray = function(itr) 
  local i = nil;
  local ret = _hx_tab_array({}, 0);
  while (true) do _hx_do_first_1 = false;
    
    i = itr();
    if (not (i ~= nil)) then 
      break;
    end;
    ret:push(i);
  end;
  do return ret end;
end
__lua_Lib.isShellAvailable = function() 
  do return false end;
end

__lua__Lua_Lua_Fields_.new = {}
_hxClasses["lua._Lua.Lua_Fields_"] = __lua__Lua_Lua_Fields_
__lua__Lua_Lua_Fields_.__name__ = "lua._Lua.Lua_Fields_"

__lua_PairTools.new = {}
_hxClasses["lua.PairTools"] = __lua_PairTools
__lua_PairTools.__name__ = "lua.PairTools"
__lua_PairTools.ipairsEach = function(table,func) 
  for i,v in ipairs(table) do func(i,v) end;
end
__lua_PairTools.pairsEach = function(table,func) 
  for k,v in pairs(table) do func(k,v) end;
end
__lua_PairTools.ipairsMap = function(table,func) 
  local ret = {};
  for i,v in ipairs(table) do ret[i] = func(i,v) end;
  do return ret end;
end
__lua_PairTools.pairsMap = function(table,func) 
  local ret = {};
  for k,v in pairs(table) do ret[k] = func(k,v) end;
  do return ret end;
end
__lua_PairTools.ipairsFold = function(table,func,seed) 
  for i,v in ipairs(table) do seed = func(i,v,seed) end;
  do return seed end;
end
__lua_PairTools.pairsFold = function(table,func,seed) 
  for k,v in pairs(table) do seed = func(k,v,seed) end;
  do return seed end;
end
__lua_PairTools.ipairsConcat = function(table1,table2) 
  local ret = {};
  __lua_PairTools.ipairsFold(table1, function(a,b,c) 
    c[a] = b;
    do return c end;
  end, ret);
  local size = table.maxn(ret);
  __lua_PairTools.ipairsFold(table2, function(a,b,c) 
    c[a + size] = b;
    do return c end;
  end, ret);
  do return ret end;
end
__lua_PairTools.pairsMerge = function(table1,table2) 
  local ret = __lua_PairTools.copy(table1);
  __lua_PairTools.pairsEach(table2, function(a,b) 
    ret[a] = b;
  end);
  do return ret end;
end
__lua_PairTools.ipairsExist = function(table,func) 
  for k,v in ipairs(table) do if func(k,v) then return true end end;
end
__lua_PairTools.pairsExist = function(table,func) 
  for k,v in pairs(table) do if func(k,v) then return true end end;
end
__lua_PairTools.copy = function(table1) 
  local ret = {};
  for k,v in pairs(table1) do ret[k] = v end;
  do return ret end;
end
__lua_PairTools.pairsIterator = function(table) 
  local _hx_1_p_next, _hx_1_p_table, _hx_1_p_index = __lua__Lua_Lua_Fields_.pairs(table);
  local next = _hx_1_p_next;
  local i = _hx_1_p_index;
  do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
    local _hx_2_res_index, _hx_2_res_value = next(table, i);
    i = _hx_2_res_index;
    do return _hx_o({__fields__={index=true,value=true},index=_hx_2_res_index,value=_hx_2_res_value}) end;
  end,hasNext=function(self) 
    do return select(2, next(table, i)) ~= nil end;
  end}) end;
end
__lua_PairTools.ipairsIterator = function(table) 
  local _hx_1_p_next, _hx_1_p_table, _hx_1_p_index = __lua__Lua_Lua_Fields_.ipairs(table);
  local next = _hx_1_p_next;
  local i = _hx_1_p_index;
  do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
    local _hx_2_res_index, _hx_2_res_value = next(table, i);
    i = _hx_2_res_index;
    do return _hx_o({__fields__={index=true,value=true},index=_hx_2_res_index,value=_hx_2_res_value}) end;
  end,hasNext=function(self) 
    do return select(2, next(table, i)) ~= nil end;
  end}) end;
end

__lua_Thread.new = {}
_hxClasses["lua.Thread"] = __lua_Thread
__lua_Thread.__name__ = "lua.Thread"

__lua_UserData.new = {}
_hxClasses["lua.UserData"] = __lua_UserData
__lua_UserData.__name__ = "lua.UserData"


_hx_array_mt.__index = Array.prototype


local _hx_static_init = function()
  
  String.__name__ = "String";
  _hxClasses.Array = Array;
  Array.__name__ = "Array";EReg.escapeRegExpRe = EReg.new("[\\[\\]{}()*+?.\\\\\\^$|]", "g");
  
  __haxe_SysTools.winMetaCharacters = _hx_tab_array({[0]=32, 40, 41, 37, 33, 94, 34, 60, 62, 38, 124, 10, 13, 44, 59}, 15);
  
  StringTools.winMetaCharacters = __haxe_SysTools.winMetaCharacters;
  
  __haxe_Template.splitter = EReg.new("(::[A-Za-z0-9_ ()&|!+=/><*.\"-]+::|\\$\\$([A-Za-z0-9_-]+)\\()", "");
  
  __haxe_Template.expr_splitter = EReg.new("(\\(|\\)|[ \r\n\t]*\"[^\"]*\"[ \r\n\t]*|[!+=/><*.&|-]+)", "");
  
  __haxe_Template.expr_trim = EReg.new("^[ ]*([^ ]+)[ ]*$", "");
  
  __haxe_Template.expr_int = EReg.new("^[0-9]+$", "");
  
  __haxe_Template.expr_float = EReg.new("^([+-]?)(?=\\d|,\\d)\\d*(,\\d*)?([Ee]([+-]?\\d+))?$", "");
  
  __haxe_Template.globals = _hx_e();
  
  __haxe_Template.hxKeepArrayIterator = __haxe_iterators_ArrayIterator.new(_hx_tab_array({}, 0));
  
  __haxe_ds_IntMap.tnull = {};
  
  __haxe_ds_ObjectMap.count = 0;
  
  __haxe_ds_StringMap.tnull = {};
  
  __lua_Boot._fid = 0;
  
  __lua_Boot.Max_Int32 = 2147483647;
  
  __lua_Boot.Min_Int32 = -2147483648;
  
  __lua_Boot.MAXSTACKSIZE = 1000;
  
  __lua_Boot.platformBigEndian = false;
  
  __lua_Boot.hiddenFields = {__id__=true, hx__closures=true, super=true, prototype=true, __fields__=true, __ifields__=true, __class__=true, __properties__=true}
  
  __lua_Boot.os_patterns = __haxe_ds_StringMap.new();
  
  
end






_hx_static_init();


return {_hx_hidden, _hx_array_mt, _hx_is_array, _hx_tab_array, _hx_print_class, _hx_print_enum, _hx_tostring, _hx_obj_newindex, _hx_obj_mt, _hx_a, _hx_e, _hx_o, _hx_new, _hx_field_arr, _hxClasses, _hx_bind, _hx_bit, _hx_staticToInstance, _hx_funcToField, _hx_maxn, _hx_print, _hx_apply_self, _hx_box_mr, _hx_bit_clamp, _hx_table, _hx_bit_raw, _hx_pcall_default, _hx_pcall_break, _hx_handle_error, _hx_static_init, Int, Dynamic, Float, Bool, Class, Enum, Array, Date, EReg, ___EnumValue_EnumValue_Impl_, IntIterator, Lambda, Math, Reflect, String, Std, StringBuf, __haxe_SysTools, StringTools, ValueType, Type, __haxe_StackItem, __haxe__CallStack_CallStack_Impl_, __haxe_IMap, __haxe_Exception, __haxe_Json, __haxe_Log, __haxe_NativeStackTrace, __haxe__Rest_Rest_Impl_, __haxe__Template_TemplateExpr, __haxe_iterators_ArrayIterator, __haxe_Template, __haxe_ValueException, __haxe_ds_BalancedTree, __haxe_ds_TreeNode, __haxe_ds_EnumValueMap, __haxe_ds_IntMap, __haxe_ds_List, __haxe_ds__List_ListNode, __haxe_ds__List_ListIterator, __haxe_ds__List_ListKeyValueIterator, __haxe_ds__Map_Map_Impl_, __haxe_ds_ObjectMap, __haxe_ds__ReadOnlyArray_ReadOnlyArray_Impl_, __haxe_ds_StringMap, __haxe_format_JsonParser, __haxe_format_JsonPrinter, __haxe_iterators_ArrayKeyValueIterator, __haxe_iterators_MapKeyValueIterator, __haxe_iterators_RestIterator, __haxe_iterators_RestKeyValueIterator, __haxe_iterators_StringIterator, __haxe_iterators_StringIteratorUnicode, __haxe_iterators_StringKeyValueIterator, __lua_Boot, __lua_Lib, __lua__Lua_Lua_Fields_, __lua_PairTools, __lua_Thread, __lua_UserData}